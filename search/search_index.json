{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FusionRings for GAP","text":"FusionRings builds fusion rings and modular data with exact arithmetic in GAP. Current Phase 2 progress includes an implemented SU(2)_k Verlinde constructor."},{"location":"#who-this-is-for","title":"Who this is for","text":"<p>This documentation is written for:</p> <ul> <li>mathematicians who want exact computations with fusion rings and modular data;</li> <li>GAP users who want practical constructors and validation workflows;</li> <li>researchers who want reproducible examples for papers (including module graphs).</li> </ul>"},{"location":"#what-is-included","title":"What is included","text":"<ul> <li>Fusion ring constructors from rules, sparse tables, and matrices.</li> <li>ModularData objects from database entries or direct <code>(S, T)</code> input.</li> <li>Validation pipeline with levels 1 to 7.</li> <li>Rank <code>&lt;= 12</code> modular data database loaders.</li> <li>Bridge from modular data to fusion rings.</li> <li>Phase 2 start: <code>VerlindeModularData(\"A\", 1, k)</code> for SU(2)_k.</li> </ul>"},{"location":"#fast-start-2-minutes","title":"Fast start (2 minutes)","text":"<pre><code>LoadPackage(\"FusionRings\");;\n\nmd := GetModularData(2, 1, 1);;\nValidateModularData(md, 4);\nF := FusionRingFromModularData(md);;\nCheckFusionRingAxioms(F, 1);\n</code></pre> <p>If both checks return <code>true</code>, your setup is working.</p>"},{"location":"#recommended-reading-order","title":"Recommended reading order","text":"<ol> <li>Getting Started</li> <li>Full Tutorial</li> <li>Fusion Rings and Modular Data</li> <li>Worked Examples</li> <li>Quick API</li> </ol>"},{"location":"#maintainer-and-citation","title":"Maintainer and citation","text":"<ul> <li>Maintainer: Cesar Galindo</li> <li>Position: Professor of Mathematics, Universidad de los Andes</li> <li>Repository: github.com/cesarneyit-code/FusionRings</li> <li>Contact: cn.galindo1116@uniandes.edu.co (or open a GitHub issue)</li> <li>If this package is useful in your work, please cite it and acknowledge the   FusionRings project in your paper/preprint.</li> <li>Citation details and BibTeX: How to Cite</li> </ul>"},{"location":"api/constructors/","title":"Constructors Reference","text":""},{"location":"api/constructors/#verlindemodulardatatype-rank-level","title":"<code>VerlindeModularData(type, rank, level)</code>","text":"<p>Current support:</p> <ul> <li>type <code>\"A\"</code>, rank <code>1</code>, level <code>k &gt;= 1</code>.</li> </ul> <p>Behavior:</p> <ul> <li>returns a <code>ModularData</code> object from exact cyclotomic S/T formulas for SU(2)_k.</li> <li>labels are <code>[0..k]</code>.</li> </ul> <p>Errors:</p> <ul> <li>non-positive level.</li> <li>unsupported type/rank pair.</li> </ul>"},{"location":"api/constructors/#verlindemodulardatabyliealgebral-level","title":"<code>VerlindeModularDataByLieAlgebra(L, level)</code>","text":"<ul> <li>declared and reserved for Phase 2 expansion.</li> <li>currently raises <code>not implemented yet</code>.</li> </ul>"},{"location":"api/constructors/#verlindemodulardatabyrootsystemr-level","title":"<code>VerlindeModularDataByRootSystem(R, level)</code>","text":"<ul> <li>declared and reserved for Phase 2 expansion.</li> <li>currently raises <code>not implemented yet</code>.</li> </ul>"},{"location":"api/quick-api/","title":"Quick API","text":"<p>If you only remember one workflow, use:</p> <pre><code>md := GetModularData(rank, iGO, iMD);;\nValidateModularData(md, 4).ok;\nF := FusionRingFromModularData(md);;\nCheckFusionRingAxioms(F, 1);\n</code></pre> <p>Then use the sections below as a function index.</p>"},{"location":"api/quick-api/#constructors","title":"Constructors","text":"<ul> <li><code>ModularData(rec | S, T[, labels])</code></li> <li><code>ModularDataFromNsdRecord(rec)</code></li> <li><code>ModularDataFromST(S, T[, labels])</code></li> <li><code>Rank2FusionRing(n)</code> (<code>tau*tau = 1 + n*tau</code>)</li> <li><code>Rank3FusionRing(k, l, m, n)</code> (rank-3 family with <code>k^2 + l^2 = k n + l m + 1</code>)</li> </ul>"},{"location":"api/quick-api/#validation-and-loaders","title":"Validation and loaders","text":"<ul> <li><code>ValidateModularData(md[, level])</code></li> <li><code>LoadNsdGOL(rank)</code></li> <li><code>GetModularData(rank, iGO, iMD)</code></li> </ul>"},{"location":"api/quick-api/#bridges-and-verlinde","title":"Bridges and Verlinde","text":"<ul> <li><code>FusionRingFromModularData(md)</code></li> <li><code>UniversalGradingFromModularData(md)</code></li> <li><code>CheckUniversalGradingEqualsInvertibles(md)</code></li> <li><code>VerlindeModularData(type, rank, level)</code></li> <li><code>VerlindeModularDataByLieAlgebra(L, level)</code></li> <li><code>VerlindeModularDataByRootSystem(R, level)</code></li> </ul>"},{"location":"api/quick-api/#invertibles-and-subrings","title":"Invertibles and subrings","text":"<ul> <li><code>IsInvertibleSimple(F, i)</code></li> <li><code>InvertibleSimples(F)</code></li> <li><code>IsPointedFusionRing(F)</code></li> <li><code>IsFusionSubring(F, subset)</code></li> <li><code>FusionSubring(F, subset)</code></li> <li><code>FusionSubringByGenerators(F, generators)</code></li> <li><code>FusionSubringLatticeSmall(F[, maxRank])</code></li> <li><code>CanonicalPointedSubring(F)</code></li> <li><code>AdjointSubring(F)</code></li> <li><code>UniversalGradingData(F)</code></li> <li><code>UniversalGradingComponent(F, i)</code></li> <li><code>UniversalGradingOrder(F)</code></li> <li><code>IsIntegralFusionRing(F)</code></li> <li><code>IsWeaklyIntegralFusionRing(F)</code></li> </ul>"},{"location":"api/quick-api/#fp-dimensions","title":"FP dimensions","text":"<ul> <li><code>FPDimensionData(F)</code></li> <li><code>FPRank(F)</code> (and <code>Rank(F)</code> helper)</li> <li><code>GlobalFPDimension(F)</code></li> <li><code>FPType(F)</code></li> <li><code>FPDimensions(F)</code> (exact algebraic values)</li> <li><code>FPDimensionPolynomials(F)</code></li> <li><code>FormalCodegrees(F)</code></li> <li><code>FPDimensionPolynomial(F, i)</code></li> <li><code>FPDimensionApprox(F, i[, digits])</code></li> <li><code>FPDimensionsApprox(F[, digits])</code></li> <li><code>FPTypeApprox(F[, digits])</code></li> </ul>"},{"location":"api/quick-api/#paper-criteria-helpers-commutative-case","title":"Paper criteria helpers (commutative case)","text":"<ul> <li><code>CheckDNumberCriterionCommutative(F)</code></li> <li><code>CheckDrinfeldCriterionCommutative(F)</code></li> <li><code>CheckExtendedCyclotomicCriterionCommutative(F)</code></li> <li><code>CheckPaperCriteriaCommutative(F)</code></li> </ul>"},{"location":"api/quick-api/#based-modules-over-fusion-rings","title":"Based modules over fusion rings","text":"<ul> <li><code>FusionModuleByActionMatrices(F, basisLabels, actionMatrices[, opts])</code></li> <li><code>UnderlyingFusionRing(M)</code>, <code>ModuleBasisLabels(M)</code>, <code>ModuleRank(M)</code></li> <li><code>ActionMatrices(M)</code>, <code>ActionMatrix(M, i)</code>, <code>ActionOnBasis(M, i, m)</code></li> <li><code>IsFusionSubmodule(M, subset)</code>, <code>FusionSubmodule(M, subset)</code></li> <li><code>FusionSubmoduleByGenerators(M, generators)</code></li> <li><code>FusionModuleComponents(M)</code></li> <li><code>IsIndecomposableFusionModule(M)</code>, <code>IsIrreducibleFusionModule(M)</code></li> <li><code>AreEquivalentFusionModules(M1, M2)</code></li> <li><code>FusionModuleGraph(M[, i])</code></li> <li><code>CanonicalFusionModule(F)</code>, <code>FusionSubmoduleByObject(F, i)</code></li> <li><code>DynkinGraphAdjacency(type[, n])</code></li> <li><code>OstrikSU2Module(k, type[, n][, opts])</code></li> <li><code>OstrikSU2Modules(k)</code></li> <li><code>IsOstrikSU2Module(M, k[, type[, n]])</code></li> <li><code>NimrepFromModule(M[, i])</code></li> <li><code>GraphSpectrumApprox(A|M|nimrep)</code></li> <li><code>CoxeterNumberFromAdjacencyApprox(A|M|nimrep)</code></li> <li><code>IsADELevelCompatible(k, type[, n])</code></li> <li><code>CheckOstrikADEData(k, type[, n])</code></li> <li><code>FusionModuleGraphDOT(graph|M[, i])</code></li> <li><code>SaveFusionModuleGraphDOT(path, graph|M[, i])</code></li> <li><code>SaveFusionModuleGraphSVG(path, graph|M[, i])</code></li> <li><code>OstrikReport(k)</code></li> </ul>"},{"location":"api/quick-api/#attributes","title":"Attributes","text":"<ul> <li><code>SMatrix(md)</code>, <code>TMatrix(md)</code>, <code>MDLabels(md)</code></li> <li><code>MDSpins(md)</code>, <code>MDTwists(md)</code>, <code>MDQuantumDimensions(md)</code></li> <li><code>MDGlobalDimensionSquared(md)</code>, <code>MDFusionCoefficients(md)</code>, <code>MDOrderT(md)</code></li> <li><code>MDGaussSums(md)</code>, <code>MDGaussSumProduct(md)</code></li> <li><code>MDCentralCharge(md)</code>, <code>MDFrobeniusSchurExponent(md)</code></li> </ul>"},{"location":"guide/api-exactness/","title":"API Exactness (Exact vs Heuristic)","text":"<p>This table summarizes which outputs are exact algebraic data and which are numeric helpers meant for inspection.</p> <p>Legend used below: - exact: suitable for symbolic/theorem-level computations; - heuristic view: decimal helper for readability, not for proofs; - partial/conservative: implemented, but may decline applicability on hard inputs.</p> API Status Notes <code>FPDimensions(F)</code> exact Algebraic values (or rational) per simple object. <code>FPDimensionPolynomial(F,i)</code> exact Polynomial associated to FP dimension of <code>i</code>. <code>FPDimensionPolynomials(F)</code> exact Per-simple polynomial list. <code>GlobalFPDimension(F)</code> exact Sum of squares of exact FP dimensions. <code>FPType(F)</code> exact Exact FP dimensions sorted by approximate size. <code>FormalCodegrees(F)</code> exact/partial Exact value + polynomial + multiplicity; ordering uses approximate values. <code>FPDimensionApprox(F,i[,digits])</code> heuristic view Decimal display helper. <code>FPDimensionsApprox(F[,digits])</code> heuristic view Decimal display helper. <code>FPTypeApprox(F[,digits])</code> heuristic view Decimal display helper. <code>IsIntegralFusionRing(F)</code> exact criterion Checks all FP dimensions are integers. <code>IsWeaklyIntegralFusionRing(F)</code> numeric check Uses decimal tolerance on global FP dimension. <code>IsInvertibleSimple(F,i)</code> exact combinatorial Checks fusion matrix is a permutation matrix. <code>IsFusionSubring(F,S)</code> exact combinatorial Closure under unit, dual, multiplication support. <code>MDGaussSums(md)</code> exact Returns Gauss sums <code>pplus</code>, <code>pminus</code> as cyclotomics. <code>MDGaussSumProduct(md)</code> exact Returns <code>pplus*pminus</code> (should equal <code>D^2</code>). <code>MDCentralCharge(md)</code> exact Returns <code>pplus/pminus</code> (root of unity). <code>MDFrobeniusSchurExponent(md)</code> exact Wrapper for <code>MDOrderT(md)</code>."},{"location":"guide/api-exactness/#quick-recommendations","title":"Quick recommendations","text":"<ul> <li>Use exact APIs for all symbolic/math pipelines.</li> <li>Use <code>*Approx</code> APIs only for readability in logs/notes.</li> <li>For weak integrality, treat current result as practical; if you need a strict   proof-level check, add an exact arithmetic variant.</li> </ul>"},{"location":"guide/api-exactness/#theorem-api-map-current-status","title":"Theorem -&gt; API map (current status)","text":"Mathematical statement / criterion API entry points Exactness status Perron-Frobenius dimensions of simples <code>FPDimensions</code>, <code>FPDimensionPolynomial</code> exact Global FP dimension <code>sum_i d_i^2</code> <code>GlobalFPDimension</code> exact Integral / weakly integral checks <code>IsIntegralFusionRing</code>, <code>IsWeaklyIntegralFusionRing</code> exact / practical numeric Invertible objects and pointedness <code>IsInvertibleSimple</code>, <code>InvertibleSimples</code>, <code>IsPointedFusionRing</code> exact Canonical pointed and adjoint subrings <code>CanonicalPointedSubring</code>, <code>AdjointSubring</code> exact combinatorial Universal grading decomposition <code>UniversalGradingData</code>, <code>UniversalGradingComponent</code>, <code>UniversalGradingOrder</code> exact combinatorial Formal codegrees <code>FormalCodegrees</code> exact/partial (ordering uses numeric helper) d-number criterion (commutative case) <code>CheckDNumberCriterionCommutative</code> exact (implemented) Drinfeld ratio criterion (commutative case) <code>CheckDrinfeldCriterionCommutative</code> partial/conservative Extended cyclotomic criterion (commutative case) <code>CheckExtendedCyclotomicCriterionCommutative</code> partial/conservative ADE/Ostrik SU(2)_k module classification <code>OstrikSU2Module</code>, <code>OstrikSU2Modules</code>, <code>IsOstrikSU2Module</code> exact by combinatorial reconstruction"},{"location":"guide/examples/","title":"Worked Examples","text":"<p>This page is a guided tour: run a command, see what GAP prints, and understand why that output matters. Start each session with:</p> <pre><code>LoadPackage(\"FusionRings\");;\n</code></pre>"},{"location":"guide/examples/#1-rank-2-family-tautau-1-ntau","title":"1) Rank-2 family (tautau = 1 + ntau)","text":"<p>The rank-2 family is parameterized by a nonnegative integer <code>n</code>. It is a useful stress-test: <code>n=0</code> is pointed (<code>C2</code>), <code>n=1</code> is Fibonacci, and larger <code>n</code> often fails deeper criteria even though the ring is defined.</p> <pre><code>F0 := Rank2FusionRing(0);;\nF1 := Rank2FusionRing(1);;\nF5 := Rank2FusionRing(5);;\n\nMultiplyBasis(F0, \"tau\", \"tau\");\nMultiplyBasis(F1, \"tau\", \"tau\");\nMultiplyBasis(F5, \"tau\", \"tau\");\n</code></pre> <p>Expected output:</p> <pre><code>[ [ \"1\", 1 ] ]\n[ [ \"1\", 1 ], [ \"tau\", 1 ] ]\n[ [ \"1\", 1 ], [ \"tau\", 5 ] ]\n</code></pre> <p>Use this family when you want a fast parameterized example with known behavior.</p>"},{"location":"guide/examples/#2-pointed-ring-in-20-seconds","title":"2) Pointed ring in 20 seconds","text":"<p>Start with a very small pointed ring (<code>CyclicPointedFusionRing(4)</code>), then check the basic product logic.</p> <pre><code>Fc4 := CyclicPointedFusionRing(4);;\nLabelsList(Fc4);\nMultiplyBasis(Fc4, 2, 2);\nCheckFusionRingAxioms(Fc4, 1);\n</code></pre> <p>Expected output:</p> <pre><code>[ &lt;identity&gt; of ..., f1, f2, f1*f2 ]\n[ [ 4, 1 ] ]\ntrue\n</code></pre> <p>Interpretation: - the second simple times itself lands in simple #4 with coefficient 1; - level-1 axioms pass.</p>"},{"location":"guide/examples/#3-rank-3-family-kk-l-m-n","title":"3) Rank-3 family K(k, l, m, n)","text":"<p>The rank-3 family has basis <code>1, X, Y</code> with rules:</p> <pre><code>X^2 = 1 + m X + k Y\nY^2 = 1 + l X + n Y\nX Y = Y X = k X + l Y\n</code></pre> <p>Parameters must satisfy:</p> <pre><code>k^2 + l^2 = k n + l m + 1\n</code></pre> <p>Example with <code>(k, l, m, n) = (0, 1, 0, 0)</code>:</p> <pre><code>F3 := Rank3FusionRing(0, 1, 0, 0);;\nMultiplyBasis(F3, \"X\", \"X\");\nMultiplyBasis(F3, \"Y\", \"Y\");\nMultiplyBasis(F3, \"X\", \"Y\");\nCheckFusionRingAxioms(F3, 1);\n</code></pre> <p>Expected output:</p> <pre><code>[ [ \"1\", 1 ] ]\n[ [ \"1\", 1 ], [ \"X\", 1 ] ]\n[ [ \"Y\", 1 ] ]\ntrue\n</code></pre> <p>Another valid parameter set is <code>(k, l, m, n) = (1, 1, 1, 0)</code> (since <code>1^2+1^2 = 1*0 + 1*1 + 1</code>):</p> <pre><code>F3b := Rank3FusionRing(1, 1, 1, 0);;\nMultiplyBasis(F3b, \"X\", \"X\");\nMultiplyBasis(F3b, \"Y\", \"Y\");\nMultiplyBasis(F3b, \"X\", \"Y\");\n</code></pre> <p>Expected output:</p> <pre><code>[ [ \"1\", 1 ], [ \"X\", 1 ], [ \"Y\", 1 ] ]\n[ [ \"1\", 1 ], [ \"X\", 1 ] ]\n[ [ \"X\", 1 ], [ \"Y\", 1 ] ]\n</code></pre>"},{"location":"guide/examples/#4-fibonacci-ising-and-tambara-yamagami","title":"4) Fibonacci, Ising, and Tambara-Yamagami","text":"<p>This is a quick family smoke test that mixes pointed/non-pointed behavior.</p> <pre><code>Ffib := FibonacciFusionRing();;\nFis := IsingFusionRing();;\nG3 := CyclicGroup(3);;\nFty := TambaraYamagamiFusionRing(G3);;\n\nCheckFusionRingAxioms(Ffib, 1);\nCheckFusionRingAxioms(Fis, 1);\nCheckFusionRingAxioms(Fty, 1);\n</code></pre> <p>Expected output:</p> <pre><code>true\ntrue\ntrue\n</code></pre> <p>Interpretation: all three constructors produce internally consistent fusion rules at level 1.</p>"},{"location":"guide/examples/#5-from-modular-data-database-to-fusion-ring","title":"5) From modular-data database to fusion ring","text":"<p>This is the core pipeline many users want: database -&gt; validated <code>ModularData</code> -&gt; <code>FusionRing</code>.</p> <pre><code>LoadNsdGOL(2);;\nmd := GetModularData(2, 1, 1);;\nv := ValidateModularData(md, 7);;\nv.ok;\n\nFmd := FusionRingFromModularData(md);;\nCheckFusionRingAxioms(Fmd, 1);\n</code></pre> <p>Expected output:</p> <pre><code>true\ntrue\n</code></pre> <p>Interpretation: - the modular datum passes validation level 7; - the reconstructed fusion ring also passes ring-axiom checks.</p>"},{"location":"guide/examples/#6-invertibles-and-canonical-pointed-subring","title":"6) Invertibles and canonical pointed subring","text":"<p>Now inspect structure inside a non-pointed ring (<code>IsingFusionRing</code>).</p> <pre><code>Fi := IsingFusionRing();;\nInvertibleSimples(Fi);\nP := CanonicalPointedSubring(Fi);;\nLabelsList(P);\nIsPointedFusionRing(P);\n</code></pre> <p>Expected output:</p> <pre><code>[ \"1\", \"psi\" ]\n[ \"1\", \"psi\" ]\ntrue\n</code></pre> <p>Interpretation: Ising has exactly two invertibles, and they generate the canonical pointed subring.</p>"},{"location":"guide/examples/#7-fp-dimensions-exact-and-approximate","title":"7) FP dimensions: exact and approximate","text":"<p>Use exact values for algebraic work and decimal approximations for quick intuition.</p> <pre><code>Ffib := FibonacciFusionRing();;\nFPDimensionPolynomial(Ffib, \"x\");\nFPDimensions(Ffib)[2];\nFPDimensionApprox(Ffib, \"x\", 8);\nGlobalFPDimension(Ffib);\n</code></pre> <p>Expected output:</p> <pre><code>x_1^2-x_1-1\nfp2\n1.61803399\nfp2+2\n</code></pre> <p>Interpretation: - the FP dimension of <code>x</code> is the positive root of <code>x^2 - x - 1</code>; - exact values stay algebraic (<code>fp2</code>), while approximations are optional.</p>"},{"location":"guide/examples/#8-paper-style-criterion-example-that-fails","title":"8) Paper-style criterion example that fails","text":"<p>This rank-4 commutative example is useful because it fails a criterion in a controlled way.</p> <pre><code>M := [\n  [ [1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1] ],\n  [ [0,1,0,0],[0,0,1,0],[1,0,0,0],[0,0,0,1] ],\n  [ [0,0,1,0],[1,0,0,0],[0,1,0,0],[0,0,0,1] ],\n  [ [0,0,0,1],[0,0,0,1],[0,0,0,1],[1,1,1,1] ]\n];;\nFbad := FusionRingByFusionMatrices([1..4], 1, fail, M, rec(inferDual := true, check := 0));;\n\ndres := CheckDNumberCriterionCommutative(Fbad);;\ndres.ok;\ndres.failures[1];\n</code></pre> <p>Expected output:</p> <pre><code>false\nformal codegree polynomial #2 fails d-number divisibility test\n</code></pre> <p>Interpretation: this is a concrete \"criterion fails\" case you can use while developing filters/classifiers.</p>"},{"location":"guide/examples/#9-full-test-run-when-you-want-confidence","title":"9) Full test run (when you want confidence)","text":"<pre><code>FusionRings_TestAllStrict();\n</code></pre> <p>This runs the package test suite and is the right command before a commit.</p>"},{"location":"guide/examples/#10-based-modules-over-a-fusion-ring","title":"10) Based modules over a fusion ring","text":"<p>The package now supports based modules (Ostrik's based modules over a based ring, i.e. modules over a fusion ring with nonnegative integral action matrices).</p> <pre><code>F2 := CyclicPointedFusionRing(2);;\nA1 := [ [1,0],[0,1] ];;\nAswap := [ [0,1],[1,0] ];;\n\nM := FusionModuleByActionMatrices(F2, [ \"a\", \"b\" ], [ A1, Aswap ]);;\nActionOnBasis(M, LabelOfPosition(F2, 2), \"a\");\nIsIrreducibleFusionModule(M);\nIsIndecomposableFusionModule(M);\n</code></pre> <p>Expected output:</p> <pre><code>[ [ \"b\", 1 ] ]\ntrue\ntrue\n</code></pre> <p>And a reducible/decomposable example:</p> <pre><code>Afix := [ [1,0],[0,1] ];;\nD := FusionModuleByActionMatrices(F2, [ \"m1\", \"m2\" ], [ A1, Afix ]);;\nFusionModuleComponents(D);\nSD := FusionSubmoduleByGenerators(D, [ \"m1\" ]);;\nModuleBasisLabels(SD);\n</code></pre> <p>Expected output:</p> <pre><code>[ [ \"m1\" ], [ \"m2\" ] ]\n[ \"m1\" ]\n</code></pre> <p>Module-graph view:</p> <pre><code>Gact := FusionModuleGraph(M, LabelOfPosition(F2, 2));;\nGact.mode;\nGact.edges;\n\nGcomb := FusionModuleGraph(D);;\nGcomb.mode;\nGcomb.edges;\n</code></pre> <p>Expected output:</p> <pre><code>\"action-directed\"\n[ [ \"a\", \"b\", 1 ], [ \"b\", \"a\", 1 ] ]\n\"combined-undirected\"\n[ [ \"m1\", \"m1\", 2 ], [ \"m2\", \"m2\", 2 ] ]\n</code></pre> <p>Canonical module of a fusion ring and cyclic submodule from one object:</p> <pre><code>Fi := IsingFusionRing();;\nCM := CanonicalFusionModule(Fi);;\nModuleBasisLabels(CM) = LabelsList(Fi);\nActionOnBasis(CM, \"sigma\", \"sigma\");\n\nSobj := FusionSubmoduleByObject(Fi, \"sigma\");;\nModuleBasisLabels(Sobj);\n</code></pre> <p>Expected output:</p> <pre><code>true\n[ [ \"1\", 1 ], [ \"psi\", 1 ] ]\n[ \"1\", \"psi\", \"sigma\" ]\n</code></pre> <p>Ostrik classification modules for <code>SU(2)_k</code> (ADE):</p> <pre><code>mods4 := OstrikSU2Modules(4);;\nList(mods4, x -&gt; x.type);\nIsOstrikSU2Module(mods4[1].module, 4, \"A\");\nIsOstrikSU2Module(mods4[2].module, 4, \"D\");\n\nmods10 := OstrikSU2Modules(10);;\nList(mods10, x -&gt; x.type);\n</code></pre> <p>Expected output:</p> <pre><code>[ \"A\", \"D\" ]\ntrue\ntrue\n[ \"A\", \"D\", \"E6\" ]\n</code></pre> <p>Universal grading (first step toward nilpotency series):</p> <pre><code>Fi := IsingFusionRing();;\nUniversalGradingOrder(Fi);\nUniversalGradingComponent(Fi, \"1\");\nUniversalGradingComponent(Fi, \"sigma\");\nUniversalGradingData(Fi).multiplication;\n</code></pre> <p>Expected output:</p> <pre><code>2\n1\n2\n[ [ 1, 2 ], [ 2, 1 ] ]\n</code></pre>"},{"location":"guide/full-tutorial/","title":"Full Tutorial","text":"<p>This is a single narrative flow you can run top-to-bottom in GAP. It is meant for new users who want to understand both the API and the expected behavior.</p> <p>At the end of this tutorial you will have: - created standard fusion-ring families; - loaded and validated modular data from the database; - bridged modular data to a fusion ring; - run exact FP-dimension and criterion checks.</p>"},{"location":"guide/full-tutorial/#step-1-load-the-package","title":"Step 1: Load the package","text":"<pre><code>LoadPackage(\"FusionRings\");;\n</code></pre>"},{"location":"guide/full-tutorial/#step-2-rank-2-family-sanity-check","title":"Step 2: Rank-2 family sanity check","text":"<pre><code>F0 := Rank2FusionRing(0);;\nF1 := Rank2FusionRing(1);;\nF5 := Rank2FusionRing(5);;\n\nMultiplyBasis(F0, \"tau\", \"tau\");\nMultiplyBasis(F1, \"tau\", \"tau\");\nMultiplyBasis(F5, \"tau\", \"tau\");\n</code></pre> <p>Expected output:</p> <pre><code>[ [ \"1\", 1 ] ]\n[ [ \"1\", 1 ], [ \"tau\", 1 ] ]\n[ [ \"1\", 1 ], [ \"tau\", 5 ] ]\n</code></pre>"},{"location":"guide/full-tutorial/#step-3-rank-3-family-sanity-check","title":"Step 3: Rank-3 family sanity check","text":"<pre><code>F3 := Rank3FusionRing(0, 1, 0, 0);;\nMultiplyBasis(F3, \"X\", \"X\");\nMultiplyBasis(F3, \"Y\", \"Y\");\nMultiplyBasis(F3, \"X\", \"Y\");\n\nF3b := Rank3FusionRing(1, 1, 1, 0);;\nMultiplyBasis(F3b, \"X\", \"X\");\nMultiplyBasis(F3b, \"Y\", \"Y\");\nMultiplyBasis(F3b, \"X\", \"Y\");\n</code></pre> <p>Expected output:</p> <pre><code>[ [ \"1\", 1 ] ]\n[ [ \"1\", 1 ], [ \"X\", 1 ] ]\n[ [ \"Y\", 1 ] ]\n[ [ \"1\", 1 ], [ \"X\", 1 ], [ \"Y\", 1 ] ]\n[ [ \"1\", 1 ], [ \"X\", 1 ] ]\n[ [ \"X\", 1 ], [ \"Y\", 1 ] ]\n</code></pre>"},{"location":"guide/full-tutorial/#step-4-quick-constructor-sanity-checks","title":"Step 4: Quick constructor sanity checks","text":"<pre><code>Ffib := FibonacciFusionRing();;\nFis := IsingFusionRing();;\nG3 := CyclicGroup(3);;\nFty := TambaraYamagamiFusionRing(G3);;\n\nCheckFusionRingAxioms(Ffib, 1);\nCheckFusionRingAxioms(Fis, 1);\nCheckFusionRingAxioms(Fty, 1);\n</code></pre> <p>Expected output:</p> <pre><code>true\ntrue\ntrue\n</code></pre>"},{"location":"guide/full-tutorial/#step-5-load-modular-data-from-the-database","title":"Step 5: Load modular data from the database","text":"<pre><code>LoadNsdGOL(2);;\nmd := GetModularData(2, 1, 1);;\nv := ValidateModularData(md, 7);;\nv.ok;\n</code></pre> <p>Expected output:</p> <pre><code>true\n</code></pre> <p>This means the selected entry passes high-level validation checks.</p>"},{"location":"guide/full-tutorial/#step-6-bridge-modular-data-into-a-fusion-ring","title":"Step 6: Bridge modular data into a fusion ring","text":"<pre><code>Fmd := FusionRingFromModularData(md);;\nCheckFusionRingAxioms(Fmd, 1);\n</code></pre> <p>Expected output:</p> <pre><code>true\n</code></pre> <p>Now you have a ring object reconstructed from modular data and verified at level 1.</p>"},{"location":"guide/full-tutorial/#step-7-understand-invertibles-and-pointed-subrings","title":"Step 7: Understand invertibles and pointed subrings","text":"<pre><code>InvertibleSimples(Fis);\nP := CanonicalPointedSubring(Fis);;\nLabelsList(P);\nIsPointedFusionRing(P);\n</code></pre> <p>Expected output:</p> <pre><code>[ \"1\", \"psi\" ]\n[ \"1\", \"psi\" ]\ntrue\n</code></pre> <p>Interpretation: Ising is not pointed, but it contains a canonical pointed part.</p>"},{"location":"guide/full-tutorial/#step-8-fp-dimensions-exact-and-approximate-views","title":"Step 8: FP dimensions (exact and approximate views)","text":"<pre><code>FPDimensionPolynomial(Ffib, \"x\");\nFPDimensions(Ffib)[2];\nFPDimensionApprox(Ffib, \"x\", 8);\nGlobalFPDimension(Ffib);\n</code></pre> <p>Expected output:</p> <pre><code>x_1^2-x_1-1\nfp2\n1.61803399\nfp2+2\n</code></pre> <p>Use exact outputs (<code>fp2</code>) for algebraic computations; use decimal approximations only for intuition and quick inspection.</p>"},{"location":"guide/full-tutorial/#step-9-criterion-failure-example-paper-style","title":"Step 9: Criterion-failure example (paper-style)","text":"<pre><code>M := [\n  [ [1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1] ],\n  [ [0,1,0,0],[0,0,1,0],[1,0,0,0],[0,0,0,1] ],\n  [ [0,0,1,0],[1,0,0,0],[0,1,0,0],[0,0,0,1] ],\n  [ [0,0,0,1],[0,0,0,1],[0,0,0,1],[1,1,1,1] ]\n];;\nFbad := FusionRingByFusionMatrices([1..4], 1, fail, M, rec(inferDual := true, check := 0));;\ndres := CheckDNumberCriterionCommutative(Fbad);;\ndres.ok;\ndres.failures[1];\n</code></pre> <p>Expected output:</p> <pre><code>false\nformal codegree polynomial #2 fails d-number divisibility test\n</code></pre> <p>This is useful as a known negative test case.</p>"},{"location":"guide/full-tutorial/#step-10-run-the-full-test-suite","title":"Step 10: Run the full test suite","text":"<pre><code>LoadPackage(\"FusionRings\");;\nFusionRings_TestAllStrict();\n</code></pre> <p>Success signal: final summary with <code>0 failures in ... files</code>.</p> <p>If you want a clean CLI run (recommended for reproducibility):</p> <pre><code>./bin/fr-test-strict\n</code></pre> <p>Where to go next: - Worked Examples for more patterns; - Theorem to Computation for paper-oriented workflows; - Quick API as a compact reference.</p>"},{"location":"guide/fusion-rings-and-modular-data/","title":"Fusion Rings and Modular Data","text":"<p>This page explains three things together:</p> <ul> <li>how to construct common FusionRing families (pointed, Tambara-Yamagami, etc.),</li> <li>how to load modular data from the database,</li> <li>and how the bridge between both layers works in practice.</li> </ul> <p>If you are new: run each code block in order. This page is written as a guided script, not only as a reference.</p>"},{"location":"guide/fusion-rings-and-modular-data/#1-load-the-package-code","title":"1) Load the package code","text":"<pre><code>LoadPackage(\"FusionRings\");;\n</code></pre>"},{"location":"guide/fusion-rings-and-modular-data/#2-fusionring-family-constructors","title":"2) FusionRing family constructors","text":""},{"location":"guide/fusion-rings-and-modular-data/#rank-2-family-tautau-1-ntau","title":"Rank-2 family (tautau = 1 + ntau)","text":"<pre><code>F0 := Rank2FusionRing(0);;\nF1 := Rank2FusionRing(1);;\nF5 := Rank2FusionRing(5);;\n\nMultiplyBasis(F0, \"tau\", \"tau\");\nMultiplyBasis(F1, \"tau\", \"tau\");\nMultiplyBasis(F5, \"tau\", \"tau\");\n</code></pre>"},{"location":"guide/fusion-rings-and-modular-data/#rank-3-family-kk-l-m-n","title":"Rank-3 family (K(k, l, m, n))","text":"<pre><code>F3 := Rank3FusionRing(0, 1, 0, 0);;\nMultiplyBasis(F3, \"X\", \"X\");\nMultiplyBasis(F3, \"Y\", \"Y\");\nMultiplyBasis(F3, \"X\", \"Y\");\n\nF3b := Rank3FusionRing(1, 1, 1, 0);;\nMultiplyBasis(F3b, \"X\", \"X\");\nMultiplyBasis(F3b, \"Y\", \"Y\");\nMultiplyBasis(F3b, \"X\", \"Y\");\n</code></pre>"},{"location":"guide/fusion-rings-and-modular-data/#pointed-families","title":"Pointed families","text":"<pre><code>G := Group((1,2,3));;\nFpt := PointedFusionRing(G);;\nCheckFusionRingAxioms(Fpt, 1);\n\nFc4 := CyclicPointedFusionRing(4);;\nCheckFusionRingAxioms(Fc4, 1);\n</code></pre>"},{"location":"guide/fusion-rings-and-modular-data/#tambara-yamagami-and-near-group","title":"Tambara-Yamagami and near-group","text":"<pre><code>A := CyclicGroup(3);;\nFty := TambaraYamagamiFusionRing(A);;\nFng := NearGroupFusionRing(A, 1);;\n\nCheckFusionRingAxioms(Fty, 1);\nCheckFusionRingAxioms(Fng, 1);\n</code></pre> <p>These are useful benchmarks because they cover both pointed and non-pointed construction patterns.</p>"},{"location":"guide/fusion-rings-and-modular-data/#3-modular-data-database-workflow","title":"3) Modular-data database workflow","text":"<pre><code>LoadNsdGOL(2);;                  # loads NsdGOL2.g\nmd := GetModularData(2, 1, 1);;\nv := ValidateModularData(md, 4);;\nv.ok;\n</code></pre> <p>The database stores compact records (<code>N, s, d</code>) and reconstructs <code>(S, T)</code> from that data.</p>"},{"location":"guide/fusion-rings-and-modular-data/#4-relationship-between-both-layers","title":"4) Relationship between both layers","text":""},{"location":"guide/fusion-rings-and-modular-data/#database-modular-data-fusionring","title":"Database modular data -&gt; FusionRing","text":"<pre><code>md := GetModularData(2, 1, 1);;\nF := FusionRingFromModularData(md);;\nCheckFusionRingAxioms(F, 1);\n</code></pre> <p>This works because database-built <code>ModularData</code> includes fusion coefficients <code>N</code>.</p>"},{"location":"guide/fusion-rings-and-modular-data/#important-caveat-for-direct-s-t-constructors","title":"Important caveat for direct <code>(S, T)</code> constructors","text":"<p><code>FusionRingFromModularData(md)</code> needs fusion coefficients <code>N</code>. When you build <code>md</code> from raw <code>(S, T)</code>, you must check whether <code>N</code> was included or inferred.</p> <pre><code>mdDB := GetModularData(2, 1, 1);;\nMDFusionCoefficients(mdDB) = fail;   # expected: false\n\nmdV := VerlindeModularData(\"A\", 1, 3);;\nMDFusionCoefficients(mdV) = fail;    # check current implementation state\n\nmd0 := GetModularData(2, 1, 1);;\nS := SMatrix(md0);; T := TMatrix(md0);;\nmdST := ModularDataFromST(S, T, [1,2]);;\nMDFusionCoefficients(mdST) = fail;   # expected: true (no inferN option)\n\nmdSTi := ModularDataFromST(S, T, [1,2], rec(inferN := true, completeData := true));;\nMDFusionCoefficients(mdSTi) = fail;  # expected: false\n</code></pre> <p>Practical rule: - if <code>MDFusionCoefficients(md) = fail</code>, do not call <code>FusionRingFromModularData(md)</code>; - either use database-backed data, a constructor that already provides <code>N</code>, or   <code>ModularDataFromST(..., rec(inferN := true, ...))</code> when appropriate.</p>"},{"location":"guide/fusion-rings-and-modular-data/#5-invertibles-pointedness-and-canonical-subrings","title":"5) Invertibles, pointedness, and canonical subrings","text":"<p>An object is invertible exactly when its fusion matrix is a permutation matrix. This gives a canonical way to extract invertibles and build a pointed subring.</p> <pre><code>Fi := IsingFusionRing();;\nIsInvertibleSimple(Fi, \"1\");      # true\nIsInvertibleSimple(Fi, \"psi\");    # true\nIsInvertibleSimple(Fi, \"sigma\");  # false\n\ninv := InvertibleSimples(Fi);;\ninv;                               # [ \"1\", \"psi\" ]\nIsPointedFusionRing(Fi);           # false\n\nP := CanonicalPointedSubring(Fi);;\nBasisLabels(P);                    # [ \"1\", \"psi\" ]\nIsPointedFusionRing(P);            # true\n</code></pre> <p>You can also test arbitrary subsets:</p> <pre><code>IsFusionSubring(Fi, [ \"1\", \"psi\" ]);    # true\nIsFusionSubring(Fi, [ \"1\", \"sigma\" ]);  # false\n</code></pre>"},{"location":"guide/fusion-rings-and-modular-data/#6-exact-fp-dimensions-and-associated-polynomials","title":"6) Exact FP dimensions and associated polynomials","text":"<p>FP dimensions are stored exactly (algebraic numbers), with optional decimal views for inspection.</p> <pre><code>F := FibonacciFusionRing();;\nFPDimensions(F);                         # exact\nFPDimensionPolynomial(F, \"x\");           # x^2 - x - 1\nFPDimensionApprox(F, \"x\", 6);            # 1.618034\nFPDimensionsApprox(F, 3);                # [ 1., 1.618 ]\n</code></pre> <p>Other useful FP helpers:</p> <pre><code>FPRank(F);\nGlobalFPDimension(F);\nFPType(F);                               # exact values (sorted by size)\nFPTypeApprox(F, 3);                      # decimal view\nFormalCodegrees(F);                      # list of records: value/polynomial/multiplicity\n</code></pre> <p>Integrality checks:</p> <pre><code>IsIntegralFusionRing(F);                 # all FPdims are integers\nIsWeaklyIntegralFusionRing(F);           # global FP dimension is an integer\n</code></pre> <p>Canonical adjoint subring:</p> <pre><code>Fi := IsingFusionRing();;\nA := AdjointSubring(Fi);;\nBasisLabels(A);                          # [ \"1\", \"psi\" ]\n</code></pre>"},{"location":"guide/fusion-rings-and-modular-data/#7-universal-grading-on-fusion-rings-worked-examples","title":"7) Universal grading on fusion rings (worked examples)","text":"<p>Ising example:</p> <pre><code>Fi := IsingFusionRing();;\nUGi := UniversalGradingData(Fi);;\nUniversalGradingOrder(Fi);\nUniversalGradingComponent(Fi, \"1\");\nUniversalGradingComponent(Fi, \"sigma\");\nUGi.multiplication;\n</code></pre> <p>Expected output:</p> <pre><code>2\n1\n2\n[ [ 1, 2 ], [ 2, 1 ] ]\n</code></pre> <p>Pointed example (<code>C4</code>):</p> <pre><code>F4 := CyclicPointedFusionRing(4);;\nUG4 := UniversalGradingData(F4);;\nUniversalGradingOrder(F4);\nUG4.one;\nUG4.isGroup;\n</code></pre> <p>Expected output:</p> <pre><code>4\n1\ntrue\n</code></pre> <p>Interpretation: - In Ising, the universal grading has two components, with <code>sigma</code> in the   nontrivial one. - In a pointed ring like <code>C4</code>, each simple gives a grading component and the   grading is a genuine finite group.</p> <p>If you want a compact summary of exact vs approximate APIs, continue with API Exactness.</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>This is the practical \"first 10 minutes\" path. You will: 1) load the package, 2) run one full modular-data -&gt; fusion-ring pipeline, 3) check a few standard families.</p> <p>Before starting, make sure <code>LoadPackage(\"FusionRings\")</code> returns <code>true</code>. If GAP cannot find the package, install/symlink it in your GAP <code>pkg/</code> directory.</p>"},{"location":"guide/getting-started/#load-the-package","title":"Load the package","text":"<pre><code>LoadPackage(\"FusionRings\");;\n</code></pre>"},{"location":"guide/getting-started/#quick-rank-2-check-tautau-1-ntau","title":"Quick rank-2 check (tautau = 1 + ntau)","text":"<p>This is the fastest sanity check because it is fully explicit and parameterized.</p> <pre><code>F0 := Rank2FusionRing(0);;\nF1 := Rank2FusionRing(1);;\nF5 := Rank2FusionRing(5);;\n\nMultiplyBasis(F0, \"tau\", \"tau\");\nMultiplyBasis(F1, \"tau\", \"tau\");\nMultiplyBasis(F5, \"tau\", \"tau\");\n</code></pre> <p>Expected output:</p> <pre><code>[ [ \"1\", 1 ] ]\n[ [ \"1\", 1 ], [ \"tau\", 1 ] ]\n[ [ \"1\", 1 ], [ \"tau\", 5 ] ]\n</code></pre>"},{"location":"guide/getting-started/#quick-rank-3-check-kk-l-m-n","title":"Quick rank-3 check (K(k, l, m, n))","text":"<p>Use the rank-3 family when you want a small but nontrivial example with two parameters and a Diophantine constraint.</p> <pre><code>F3 := Rank3FusionRing(0, 1, 0, 0);;\nMultiplyBasis(F3, \"X\", \"X\");\nMultiplyBasis(F3, \"Y\", \"Y\");\nMultiplyBasis(F3, \"X\", \"Y\");\n\nF3b := Rank3FusionRing(1, 1, 1, 0);;\nMultiplyBasis(F3b, \"X\", \"X\");\nMultiplyBasis(F3b, \"Y\", \"Y\");\nMultiplyBasis(F3b, \"X\", \"Y\");\n</code></pre> <p>Expected output:</p> <pre><code>[ [ \"1\", 1 ] ]\n[ [ \"1\", 1 ], [ \"X\", 1 ] ]\n[ [ \"Y\", 1 ] ]\n[ [ \"1\", 1 ], [ \"X\", 1 ], [ \"Y\", 1 ] ]\n[ [ \"1\", 1 ], [ \"X\", 1 ] ]\n[ [ \"X\", 1 ], [ \"Y\", 1 ] ]\n</code></pre>"},{"location":"guide/getting-started/#core-sanity-check","title":"Core sanity check","text":"<p>This verifies the end-to-end path: database entry -&gt; <code>ModularData</code> -&gt; validation -&gt; <code>FusionRing</code>.</p> <pre><code>md := GetModularData(2, 1, 1);;\nv := ValidateModularData(md, 4);;\nv.ok;\nF := FusionRingFromModularData(md);;\nCheckFusionRingAxioms(F, 1);\n</code></pre> <p>Expected output:</p> <pre><code>true\ntrue\n</code></pre> <p>If both are <code>true</code>, the core pipeline is healthy.</p> <p>What this means mathematically: - the selected modular datum is internally consistent (up to validation level 4); - its fusion coefficients define a valid fusion ring object.</p>"},{"location":"guide/getting-started/#fusion-ring-family-smoke-test","title":"Fusion ring family smoke test","text":"<pre><code>Ffib := FibonacciFusionRing();;\nFis := IsingFusionRing();;\nG := CyclicGroup(3);;\nFty := TambaraYamagamiFusionRing(G);;\nFng := NearGroupFusionRing(G, 1);;\n\nCheckFusionRingAxioms(Ffib, 1);\nCheckFusionRingAxioms(Fis, 1);\nCheckFusionRingAxioms(Fty, 1);\nCheckFusionRingAxioms(Fng, 1);\n</code></pre> <p>Why these four? - Fibonacci and Ising are standard small benchmark categories. - Tambara-Yamagami and near-group cover non-pointed family constructors.</p> <p>Expected output:</p> <pre><code>true\ntrue\ntrue\ntrue\n</code></pre> <p>For pointed examples and the bridge to modular data, see <code>Fusion Rings and Modular Data</code>.</p>"},{"location":"guide/getting-started/#run-tests","title":"Run tests","text":"<p>Strict:</p> <pre><code>LoadPackage(\"FusionRings\");;\nFusionRings_TestAllStrict();\n</code></pre> <p>Expected final line (success case): <code>0 failures in ... files</code></p> <p>Tolerant:</p> <pre><code>LoadPackage(\"FusionRings\");;\nFusionRings_TestAll();\n</code></pre> <p>CI helper (tests + docs):</p> <pre><code>LoadPackage(\"FusionRings\");;\nFusionRings_CI();\n</code></pre> <p>Professional CLI workflow (clean session):</p> <pre><code>./bin/fr-test-strict\n</code></pre> <p>This runs GAP in a clean session with a local package path and avoids any <code>Reread</code>-related warnings.</p> <p>Recommended before pushing changes: - run <code>FusionRings_TestAllStrict();</code> - then run your local examples once more to confirm expected output.</p>"},{"location":"guide/how-to-cite/","title":"How to Cite","text":"<p>If FusionRings contributed to your research, please cite the project and acknowledge it in your paper/preprint.</p>"},{"location":"guide/how-to-cite/#suggested-citation-bibtex","title":"Suggested citation (BibTeX)","text":"<pre><code>@software{FusionRingsGAP2026,\n  author       = {Cesar Galindo},\n  title        = {FusionRings for GAP},\n  year         = {2026},\n  version      = {0.2.1},\n  url          = {https://github.com/cesarneyit-code/FusionRings},\n  note         = {GAP package for fusion rings, modular data, and based-module computations}\n}\n</code></pre>"},{"location":"guide/how-to-cite/#website-and-source","title":"Website and source","text":"<ul> <li>Documentation: https://cesarneyit-code.github.io/FusionRings/</li> <li>Repository: https://github.com/cesarneyit-code/FusionRings</li> </ul>"},{"location":"guide/how-to-cite/#contact","title":"Contact","text":"<ul> <li>Cesar Galindo</li> <li>Professor of Mathematics, Universidad de los Andes</li> <li>Email: cn.galindo1116@uniandes.edu.co</li> </ul>"},{"location":"guide/manual-construction/","title":"Manual Construction","text":"<p>This page shows direct constructors for FusionRing and ModularData objects.</p>"},{"location":"guide/manual-construction/#0-rank-2-family-tautau-1-ntau","title":"0) Rank-2 family (tautau = 1 + ntau)","text":"<pre><code>F0 := Rank2FusionRing(0);;\nF1 := Rank2FusionRing(1);;\nF5 := Rank2FusionRing(5);;\n\nMultiplyBasis(F0, \"tau\", \"tau\");\nMultiplyBasis(F1, \"tau\", \"tau\");\nMultiplyBasis(F5, \"tau\", \"tau\");\n</code></pre>"},{"location":"guide/manual-construction/#0b-rank-3-family-kk-l-m-n","title":"0b) Rank-3 family (K(k, l, m, n))","text":"<pre><code>F3 := Rank3FusionRing(0, 1, 0, 0);;\nMultiplyBasis(F3, \"X\", \"X\");\nMultiplyBasis(F3, \"Y\", \"Y\");\nMultiplyBasis(F3, \"X\", \"Y\");\n\nF3b := Rank3FusionRing(1, 1, 1, 0);;\nMultiplyBasis(F3b, \"X\", \"X\");\nMultiplyBasis(F3b, \"Y\", \"Y\");\nMultiplyBasis(F3b, \"X\", \"Y\");\n</code></pre>"},{"location":"guide/manual-construction/#1-fusion-ring-from-sparse-product-table","title":"1) Fusion ring from sparse product table","text":"<pre><code>LoadPackage(\"FusionRings\");;\n\nlabels := [ \"1\", \"x\" ];;\nprodTable := [\n  [ \"1\", \"1\", [ [ \"1\", 1 ] ] ],\n  [ \"1\", \"x\", [ [ \"x\", 1 ] ] ],\n  [ \"x\", \"1\", [ [ \"x\", 1 ] ] ],\n  [ \"x\", \"x\", [ [ \"1\", 1 ], [ \"x\", 1 ] ] ]\n];;\n\nF := FusionRingBySparseConstants(labels, \"1\", [\"1\",\"x\"], prodTable, rec(check := 2));;\nCheckFusionRingAxioms(F, 2);\n</code></pre>"},{"location":"guide/manual-construction/#2-fusion-ring-from-fusion-matrices","title":"2) Fusion ring from fusion matrices","text":"<pre><code>M := [\n  [ [1,0],[0,1] ],\n  [ [0,1],[1,1] ]\n];;\nF := FusionRingByFusionMatrices([\"1\",\"x\"], \"1\", [\"1\",\"x\"], M, rec(check := 2));;\n</code></pre>"},{"location":"guide/manual-construction/#3-modular-data-from-s-t","title":"3) Modular data from <code>(S, T)</code>","text":"<pre><code>md0 := GetModularData(2, 1, 1);;\nS := SMatrix(md0);;\nT := TMatrix(md0);;\n\nmd := ModularDataFromST(S, T, [1,2], rec(inferN := true, completeData := true));;\nValidateModularData(md, 3).ok;\n</code></pre>"},{"location":"guide/manual-construction/#4-bridge-to-fusion-ring","title":"4) Bridge to fusion ring","text":"<pre><code>F := FusionRingFromModularData(md);;\nCheckFusionRingAxioms(F, 1);\n</code></pre>"},{"location":"guide/manual-construction/#5-build-subrings-by-generators","title":"5) Build subrings by generators","text":"<pre><code>Fi := IsingFusionRing();;\nP := FusionSubringByGenerators(Fi, [\"psi\"]);;\nLabelsList(P);   # [ \"1\", \"psi\" ]\n</code></pre>"},{"location":"guide/modular-data/","title":"Modular Data","text":"<p><code>ModularData</code> stores:</p> <ul> <li><code>S</code>, <code>T</code></li> <li>labels</li> <li>optional fusion coefficients <code>N</code></li> <li>quantum dimensions <code>d</code></li> <li>spins <code>s</code></li> <li>twists <code>theta</code></li> <li>global dimension squared <code>D2</code></li> <li>order of <code>T</code> (<code>ordT</code>)</li> </ul> <p>Conceptually, a <code>ModularData</code> object is the package's canonical container for the modular pair <code>(S, T)</code> and its derived invariants. Once this object exists, all validation, database workflows, and fusion-ring conversion become uniform.</p> <p>If you are new to this layer, use this sequence: 1. load one database object (<code>GetModularData</code>); 2. validate (<code>ValidateModularData</code>); 3. bridge to a fusion ring (<code>FusionRingFromModularData</code>).</p>"},{"location":"guide/modular-data/#constructors","title":"Constructors","text":"<pre><code>ModularData(rec);\nModularDataFromNsdRecord(rec);\nModularDataFromST(S, T[, labels]);\n</code></pre> <p><code>ModularDataFromST</code> also accepts an options record as the last argument:</p> <pre><code>md := ModularDataFromST(S, T, labels, rec(inferN := true, completeData := true));;\n</code></pre> <ul> <li><code>inferN := true</code> attempts to infer fusion coefficients via Verlinde.</li> <li><code>completeData := true</code> fills derived fields (<code>d</code>, <code>D2</code>, <code>theta</code>, <code>ordT</code>).</li> </ul>"},{"location":"guide/modular-data/#database-backed-flow","title":"Database-backed flow","text":"<pre><code>LoadNsdGOL(rank);\nmd := GetModularData(rank, iGO, iMD);\n</code></pre> <p>This loads an entry from <code>pkg/FusionRings/data/modular_data/NsdGOL*.g</code>, reconstructs <code>S</code> from <code>(N, s, d)</code>, and builds a typed <code>ModularData</code> object.</p> <p>In other words: the database is compact (<code>N, s, d</code>), and <code>S</code> is reconstructed deterministically through the balancing equation.</p>"},{"location":"guide/modular-data/#database-files-and-indexing","title":"Database files and indexing","text":"<ul> <li>Files are split by rank: <code>NsdGOL2.g</code>, <code>NsdGOL3.g</code>, ..., <code>NsdGOL12.g</code>.</li> <li>Each file defines global <code>NsdGOL</code>.</li> <li><code>NsdGOL[iGO]</code> is one Galois orbit.</li> <li><code>NsdGOL[iGO][iMD]</code> is one modular data entry in that orbit.</li> </ul> <p>Quick inspection:</p> <pre><code>LoadPackage(\"FusionRings\");;\n\nrank := 3;;\nLoadNsdGOL(rank);;\nnsd := ValueGlobal(\"NsdGOL\");;\nPrint(\"orbits: \", Length(nsd), \"\\n\");\nPrint(\"entries in first orbit: \", Length(nsd[1]), \"\\n\");\n</code></pre> <p>This tells you how many Galois orbits are available at that rank, and how many entries are in a specific orbit.</p>"},{"location":"guide/modular-data/#end-to-end-database-validation-fusion-ring","title":"End-to-end: database -&gt; validation -&gt; fusion ring","text":"<pre><code>LoadPackage(\"FusionRings\");;\n\nmd := GetModularData(2, 1, 1);;\nv := ValidateModularData(md, 4);;\nif not v.ok then\n  Error(String(v.failures));\nfi;\n\nF := FusionRingFromModularData(md);;\nCheckFusionRingAxioms(F, 1);\n</code></pre> <p>If <code>ValidateModularData</code> fails, inspect <code>v.failures</code> before converting to a fusion ring. That keeps debugging localized to the modular-data layer.</p>"},{"location":"guide/modular-data/#bridge-condition-when-conversion-to-fusionring-is-possible","title":"Bridge condition: when conversion to FusionRing is possible","text":"<p><code>FusionRingFromModularData(md)</code> requires fusion coefficients <code>N</code>.</p> <ul> <li>Database entries loaded with <code>GetModularData</code> include <code>N</code>.</li> <li>Direct <code>(S, T)</code> construction may omit <code>N</code> unless you request inference.</li> </ul> <p>Quick check:</p> <pre><code>mdDB := GetModularData(2, 1, 1);;\nMDFusionCoefficients(mdDB) = fail;   # false\n\nmd0 := GetModularData(2, 1, 1);;\nS := SMatrix(md0);; T := TMatrix(md0);;\nmdST := ModularDataFromST(S, T, [1,2]);;\nMDFusionCoefficients(mdST) = fail;   # typically true\n\nmdSTi := ModularDataFromST(S, T, [1,2], rec(inferN := true, completeData := true));;\nMDFusionCoefficients(mdSTi) = fail;  # typically false\n</code></pre> <p>Always check <code>MDFusionCoefficients(md) = fail</code> before bridging.</p>"},{"location":"guide/modular-data/#universal-grading-check-from-modular-data","title":"Universal grading check from modular data","text":"<p>For modular-data entries with fusion coefficients, you can check the expected relation <code>|U(C)| = number of invertible simples</code> through the fusion-ring bridge:</p> <pre><code>md := GetModularData(2, 1, 1);;\nug := UniversalGradingFromModularData(md);;\nchk := CheckUniversalGradingEqualsInvertibles(md);;\nchk.ok;\n</code></pre> <p>If <code>N</code> is unavailable (<code>MDFusionCoefficients(md) = fail</code>), the check reports <code>applicable := false</code>.</p> <p>Worked output for the rank-2 database entry:</p> <pre><code>md := GetModularData(2, 1, 1);;\nchk := CheckUniversalGradingEqualsInvertibles(md);;\nchk.universalGradingOrder;\nchk.invertibleCount;\nchk.ok;\n</code></pre> <p>Expected output:</p> <pre><code>2\n2\ntrue\n</code></pre> <p>This is the modular-data version of the statement that for modular categories the universal grading group size matches the number of invertible simples.</p>"},{"location":"guide/modular-data/#gauss-sums-and-central-charge","title":"Gauss sums and central charge","text":"<p>The paper uses Gauss sums and the ratio (p_+/p_-) (central charge). These are computable directly from the modular data:</p> <pre><code>md := GetModularData(2, 1, 1);;\ngs := MDGaussSums(md);;\ngs.pplus;\ngs.pminus;\n\nMDCentralCharge(md);\nMDGaussSumProduct(md);\nMDFrobeniusSchurExponent(md);\n</code></pre> <p>Expected output for the rank-2 database example:</p> <pre><code>1\n1\nE(4)\n1\n4\n</code></pre> <p>Note: <code>MDGaussSums</code> returns a record with fields <code>pplus</code> and <code>pminus</code>.</p>"},{"location":"guide/ostrik-ade-modules/","title":"Ostrik ADE Modules","text":"<p>This page explains the graph picture behind Ostrik's classification for <code>SU(2)_k</code> module categories, and how the package names/functions map to it.</p>"},{"location":"guide/ostrik-ade-modules/#0-load-packages","title":"0) Load packages","text":"<p>Main package:</p> <pre><code>LoadPackage(\"FusionRings\");;\n</code></pre> <p>Optional graph toolkit inside GAP:</p> <pre><code>LoadPackage(\"grape\");;\n</code></pre> <p><code>grape</code> is not required for FusionRings itself. It is only for extra graph operations/visual checks.</p>"},{"location":"guide/ostrik-ade-modules/#1-notation-bridge-paper-vs-gap","title":"1) Notation bridge: paper vs GAP","text":"<ul> <li>In Ostrik's paper, the category is written as <code>C_l</code> (level <code>l</code>).</li> <li>In this package we use the usual <code>SU(2)_k</code> notation (level <code>k</code>).</li> <li>For this family, you can read <code>l = k</code>.</li> </ul> <p>In GAP, the ring side is created by:</p> <pre><code>md := VerlindeModularData(\"A\", 1, k);;\nF := FusionRingFromModularData(md);;\n</code></pre>"},{"location":"guide/ostrik-ade-modules/#2-what-is-the-graph-here","title":"2) What is \"the graph\" here?","text":"<p>For a based module <code>M</code> over the fusion ring <code>F</code>, the fundamental simple object (<code>X_1</code>) acts by a nonnegative integer matrix <code>A</code>. This is the nimrep adjacency matrix, so it defines a graph.</p> <p>For <code>SU(2)_k</code>, all action matrices are reconstructed by:</p> <p><code>N_1 = I</code>, <code>N_2 = A</code>, <code>N_{j+1} = A*N_j - N_{j-1}</code>.</p> <p>That is exactly why one graph can reconstruct the whole module action in this family.</p>"},{"location":"guide/ostrik-ade-modules/#3-ade-statement-informal","title":"3) ADE statement (informal)","text":"<p>At fixed level <code>k</code>, irreducible module categories over <code>SU(2)_k</code> correspond to ADE diagrams with Coxeter number <code>h = k + 2</code>:</p> <ul> <li><code>A_{k+1}</code> always,</li> <li><code>D_{k/2+2}</code> for even <code>k</code>,</li> <li>exceptional: <code>E6</code> at <code>k=10</code>, <code>E7</code> at <code>k=16</code>, <code>E8</code> at <code>k=28</code>.</li> </ul>"},{"location":"guide/ostrik-ade-modules/#4-apis-in-this-package","title":"4) APIs in this package","text":"<ul> <li><code>DynkinGraphAdjacency(type[, n])</code></li> <li><code>OstrikSU2Module(k, type[, n][, opts])</code></li> <li><code>OstrikSU2Modules(k)</code></li> <li><code>IsOstrikSU2Module(M, k[, type[, n]])</code></li> <li><code>FusionModuleGraph(M[, i])</code> (graph data: vertices/edges/adjacency)</li> </ul>"},{"location":"guide/ostrik-ade-modules/#5-quick-examples","title":"5) Quick examples","text":"<pre><code>mods4 := OstrikSU2Modules(4);;\nList(mods4, x -&gt; x.type);\n# [ \"A\", \"D\" ]\n\nmods10 := OstrikSU2Modules(10);;\nList(mods10, x -&gt; x.type);\n# [ \"A\", \"D\", \"E6\" ]\n</code></pre> <p>Validation check:</p> <pre><code>M := OstrikSU2Module(10, \"E6\");;\nIsOstrikSU2Module(M, 10, \"E6\");\n# true\n</code></pre>"},{"location":"guide/ostrik-ade-modules/#6-built-in-graph-data-and-visualization-paths","title":"6) Built-in graph data and visualization paths","text":""},{"location":"guide/ostrik-ade-modules/#a-in-package-textrecords","title":"A) In-package (text/records)","text":"<pre><code>M := OstrikSU2Module(4, \"D\");;\ng := FusionModuleGraph(M, LabelOfPosition(UnderlyingFusionRing(M), 2));;\ng.mode;\ng.edges;\n</code></pre> <p>This gives edges as triples <code>[source, target, weight]</code>.</p>"},{"location":"guide/ostrik-ade-modules/#b-visualize-inside-gap-via-grape","title":"B) Visualize inside GAP via GRAPE","text":"<p>If GRAPE is installed (it is available in this environment), you can build a graph object from adjacency:</p> <pre><code>LoadPackage(\"grape\");;\nadj := DynkinGraphAdjacency(\"E6\");;\nG := Graph(Group(()), [1..Length(adj)], OnPoints,\n  function(x, y) return adj[y][x] &lt;&gt; 0; end, true);;\nOrderGraph(G);;\nIsConnectedGraph(G);;\n</code></pre>"},{"location":"guide/ostrik-ade-modules/#c-export-to-dot-graphviz","title":"C) Export to DOT (Graphviz)","text":"<p>You can print DOT from <code>FusionModuleGraph</code> and render with Graphviz:</p> <pre><code>M := OstrikSU2Module(4, \"D\");;\ng := FusionModuleGraph(M, LabelOfPosition(UnderlyingFusionRing(M), 2));;\nPrint(\"digraph Nimrep {\\n\");\nfor e in g.edges do\n  Print(\"  \\\"\", e[1], \"\\\" -&gt; \\\"\", e[2], \"\\\" [label=\\\"\", e[3], \"\\\"];\\n\");\nod;\nPrint(\"}\\n\");\n</code></pre> <p>Then save as <code>nimrep.dot</code> and run:</p> <pre><code>dot -Tpng nimrep.dot -o nimrep.png\n</code></pre> <p>Package helper for SVG output:</p> <pre><code>SaveFusionModuleGraphSVG(\"nimrep.svg\", M, LabelOfPosition(UnderlyingFusionRing(M), 2));\n</code></pre>"},{"location":"guide/ostrik-ade-modules/#7-reference-shapes-static","title":"7) Reference shapes (static)","text":"<p>Typical examples:</p> <p></p> <p></p> <p></p>"},{"location":"guide/paper-criteria/","title":"Paper Criteria Examples","text":"<p>This page shows how to prototype criteria from <code>classification_fusion_rings.tex</code> using currently available FusionRings APIs.</p>"},{"location":"guide/paper-criteria/#1-formal-codegrees-drinfeldd-number-workflows","title":"1) Formal codegrees (Drinfeld/d-number workflows)","text":"<pre><code>LoadPackage(\"FusionRings\");;\n\nF := CyclicPointedFusionRing(4);;\nfc := FormalCodegrees(F);;\nfc;\n</code></pre> <p>Each entry contains: - <code>value</code> (exact when available), - <code>polynomial</code>, - <code>multiplicity</code>, - <code>approx</code> (numeric helper).</p>"},{"location":"guide/paper-criteria/#2-integrality-style-checks","title":"2) Integrality style checks","text":"<pre><code>Fi := IsingFusionRing();;\nIsIntegralFusionRing(Fi);        # false\nIsWeaklyIntegralFusionRing(Fi);  # true\n\nF4 := CyclicPointedFusionRing(4);;\nIsIntegralFusionRing(F4);        # true\nIsWeaklyIntegralFusionRing(F4);  # true\n</code></pre>"},{"location":"guide/paper-criteria/#3-pointed-invertible-subring-structure","title":"3) Pointed / invertible / subring structure","text":"<pre><code>Fi := IsingFusionRing();;\nInvertibleSimples(Fi);            # [ \"1\", \"psi\" ]\nP := CanonicalPointedSubring(Fi);;\nIsPointedFusionRing(P);           # true\n</code></pre>"},{"location":"guide/paper-criteria/#4-modular-data-validation-as-criterion-pipeline","title":"4) Modular-data validation as criterion pipeline","text":"<pre><code>md := GetModularData(2, 1, 1);;\nfor l in [1..7] do\n  v := ValidateModularData(md, l);;\n  Print(\"level \", l, \" -&gt; \", v.ok, \"\\n\");\nod;\n</code></pre>"},{"location":"guide/paper-criteria/#5-reproducing-paper-style-computations","title":"5) Reproducing paper-style computations","text":"<p>Today, the package already supports core ingredients used in the paper: - fusion matrices, - exact FP dimensions and type, - formal codegrees, - layered modular-data validation.</p> <p>Next natural additions are dedicated APIs for Schur/Drinfeld/d-number/cyclotomic criteria directly as one-call checks.</p>"},{"location":"guide/paper-criteria/#6-example-from-the-paper-appendix-criterion-failure","title":"6) Example from the paper appendix (criterion failure)","text":"<p>The following rank-4 commutative example (same matrix data as in the TeX appendix) fails the d-number check:</p> <pre><code>M := [\n  [ [1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1] ],\n  [ [0,1,0,0],[0,0,1,0],[1,0,0,0],[0,0,0,1] ],\n  [ [0,0,1,0],[1,0,0,0],[0,1,0,0],[0,0,0,1] ],\n  [ [0,0,0,1],[0,0,0,1],[0,0,0,1],[1,1,1,1] ]\n];;\nF := FusionRingByFusionMatrices([1..4], 1, fail, M, rec(inferDual := true, check := 0));;\n\nCheckDNumberCriterionCommutative(F);\nCheckDrinfeldCriterionCommutative(F);\nCheckExtendedCyclotomicCriterionCommutative(F);\n</code></pre> <p>Current implementation notes: - d-number helper is exact from formal-codegree polynomials. - Drinfeld and extended cyclotomic helpers are currently conservative and may   report <code>applicable := false</code> when exact number-field checks are not yet available.</p>"},{"location":"guide/phase2-verlinde/","title":"Phase 2: Verlinde / Root-System Layer","text":""},{"location":"guide/phase2-verlinde/#current-status","title":"Current status","text":"<p>Implemented now:</p> <ul> <li><code>VerlindeModularData(\"A\", 1, k)</code> for SU(2)_k (<code>k &gt;= 1</code>).</li> </ul> <p>Still pending:</p> <ul> <li><code>VerlindeModularData</code> for other types/ranks.</li> <li><code>VerlindeModularDataByLieAlgebra(L, level)</code>.</li> <li><code>VerlindeModularDataByRootSystem(R, level)</code>.</li> </ul>"},{"location":"guide/phase2-verlinde/#su2_k-formulas","title":"SU(2)_k formulas","text":"<p>For labels <code>a,b in {0,..,k}</code> and <code>q = exp(pi i / (k+2))</code>:</p> <pre><code>S_ab = (q^((a+1)(b+1)) - q^-((a+1)(b+1))) / (q - q^-1)\nT_aa = exp(pi i * a(a+2) / (2(k+2)))\n</code></pre> <p>In GAP cyclotomic notation:</p> <pre><code>q := E(2*(k+2));\nS_ab := (q^((a+1)*(b+1)) - q^-((a+1)*(b+1))) / (q - q^-1);\nT_aa := E(4*(k+2))^(a*(a+2));\n</code></pre>"},{"location":"guide/phase2-verlinde/#validation-example","title":"Validation example","text":"<pre><code>for k in [1..5] do\n  md := VerlindeModularData(\"A\", 1, k);;\n  v4 := ValidateModularData(md, 4);;\n  if not v4.ok then\n    Error(Concatenation(\"SU(2) level \", String(k), \" failed\"));\n  fi;\nod;\n</code></pre>"},{"location":"guide/rank5-lowrankimrn/","title":"Rank-5 Classification (LowrankIMRN)","text":"<p>This section summarizes the rank-5 classification result from <code>LowrankIMRN.tex</code> and shows how to compute the corresponding fusion rules and modular data in GAP.</p>"},{"location":"guide/rank5-lowrankimrn/#definitions-brief","title":"Definitions (brief)","text":"<ul> <li>Rank: the number of isomorphism classes of simple objects.</li> <li>Modular data: the pair <code>(S, T)</code> of matrices satisfying the modular   relations; it determines fusion rules via the Verlinde formula.</li> <li>Grothendieck equivalence: two modular categories have the same fusion   rules (i.e., isomorphic Grothendieck rings), even if they are not equivalent   as braided categories.</li> </ul>"},{"location":"guide/rank5-lowrankimrn/#the-rank-5-classification-paper-statement","title":"The rank-5 classification (paper statement)","text":"<p>The paper proves that any rank-5 modular category is Grothendieck equivalent to one of the following four families:</p> <ol> <li><code>SU(2)_4</code></li> <li><code>SU(2)_9 / Z2</code></li> <li><code>SU(5)_1</code></li> <li><code>SU(3)_4 / Z3</code></li> </ol> <p>This is a complete list of possible fusion rules for rank-5 modular categories.</p>"},{"location":"guide/rank5-lowrankimrn/#how-to-compute-these-in-fusionrings","title":"How to compute these in FusionRings","text":""},{"location":"guide/rank5-lowrankimrn/#1-su2_4-direct-verlinde","title":"1) <code>SU(2)_4</code> (direct Verlinde)","text":"<pre><code>LoadPackage(\"FusionRings\");;\n\nmd := VerlindeModularData(\"A\", 1, 4);;\nValidateModularData(md, 4).ok;\nF := FusionRingFromModularData(md);;\nCheckFusionRingAxioms(F, 1);\n</code></pre> <p>Gauss sums and central charge:</p> <pre><code>gs := MDGaussSums(md);;\ngs.pplus;\ngs.pminus;\nMDCentralCharge(md);\n</code></pre>"},{"location":"guide/rank5-lowrankimrn/#2-su5_1-pointed","title":"2) <code>SU(5)_1</code> (pointed)","text":"<p>The fusion rules are pointed with group <code>Z5</code>:</p> <pre><code>F := CyclicPointedFusionRing(5);;\nIsPointedFusionRing(F);\n</code></pre>"},{"location":"guide/rank5-lowrankimrn/#3-the-two-quotient-families-su2_9z2-and-su3_4z3","title":"3) The two quotient families <code>SU(2)_9/Z2</code> and <code>SU(3)_4/Z3</code>","text":"<p>These are not yet produced by a direct Verlinde constructor in this package, but they do appear in the rank-5 modular-data database (<code>NsdGOL5</code>).</p> <pre><code>LoadNsdGOL(5);;\nmd := GetModularData(5, iGO, iMD);;   # choose an orbit/entry\nValidateModularData(md, 7).ok;\nF := FusionRingFromModularData(md);;\nCheckFusionRingAxioms(F, 1);\n</code></pre>"},{"location":"guide/rank5-lowrankimrn/#application-scanning-all-rank-5-entries","title":"Application: scanning all rank-5 entries","text":"<p>This script iterates every rank-5 modular datum and prints a few invariants useful for matching the four families.</p> <pre><code>LoadPackage(\"FusionRings\");;\nLoadNsdGOL(5);;\nnsd := ValueGlobal(\"NsdGOL\");;\n\nfor iGO in [1..Length(nsd)] do\n  for iMD in [1..Length(nsd[iGO])] do\n    md := GetModularData(5, iGO, iMD);;\n    F := FusionRingFromModularData(md);;\n    inv := Length(InvertibleSimples(F));\n    dims := FPDimensions(F);;\n    Print(\"orbit=\", iGO, \" entry=\", iMD,\n          \" invertibles=\", inv,\n          \" dims=\", dims, \"\\n\");\n  od;\nod;\n</code></pre> <p>Typical patterns:</p> <ul> <li>Pointed (SU(5)_1): all FP dimensions are <code>1</code>, invertibles = 5.</li> <li>SU(2)_4: appears as a non-pointed entry with one dimension <code>2</code> and   a characteristic rank-5 SU(2) fusion structure.</li> <li>SU(2)_9/Z2 and SU(3)_4/Z3: non-pointed, non-isomorphic fusion rules;   both are present as distinct Galois orbits in <code>NsdGOL5</code>.</li> </ul>"},{"location":"guide/rank5-lowrankimrn/#identification-table-rank-5-database","title":"Identification table (rank-5 database)","text":"<p>The following table is generated automatically from the rank-5 database using the CLI workflow in this repo:</p> <pre><code>./bin/fr-scan-rank5 --md webdocs/guide/rank5_table.generated.md\n</code></pre>"},{"location":"guide/rank5-lowrankimrn/#reproducible-cli-scripts-recommended","title":"Reproducible CLI scripts (recommended)","text":"<p>From the repository root:</p> <pre><code>./bin/fr-scan-rank5\n</code></pre> <p>This prints a CSV-like table:</p> <pre><code>iGO,iMD,invertibles,fp_dims_sorted_approx,ordT,central_charge\n1,1,5,[ 1., 1., 1., 1., 1. ],5,E(5)\n...\n</code></pre> <p>Write the same output to a file:</p> <pre><code>./bin/fr-scan-rank5 --csv rank5_scan.csv\n</code></pre> <p>Generate a ready-to-paste Markdown table:</p> <pre><code>./bin/fr-scan-rank5 --md rank5_table.md\n</code></pre> <p>And a quick end-to-end demo:</p> <pre><code>./bin/fr-example-lowrank\n</code></pre>"},{"location":"guide/rank5-lowrankimrn/#invariants-from-modular-data-as-used-in-lowrankimrn","title":"Invariants from modular data (as used in LowrankIMRN)","text":"<p>The paper repeatedly uses the following quantities, all computable from <code>ModularData</code>:</p> <ul> <li>Quantum dimensions <code>MDQuantumDimensions(md)</code></li> <li>Global dimension squared <code>MDGlobalDimensionSquared(md)</code></li> <li>Gauss sums <code>MDGaussSums(md)</code> and <code>MDGaussSumProduct(md)</code></li> <li>Central charge <code>MDCentralCharge(md)</code></li> <li>Frobenius\u2013Schur exponent <code>MDFrobeniusSchurExponent(md)</code> (equals <code>MDOrderT(md)</code>)</li> </ul> <p>Minimal example:</p> <pre><code>md := GetModularData(2, 1, 1);;\nMDQuantumDimensions(md);\nMDGlobalDimensionSquared(md);\nMDGaussSums(md);\nMDCentralCharge(md);\nMDFrobeniusSchurExponent(md);\n</code></pre>"},{"location":"guide/rank5-lowrankimrn/#practical-takeaway","title":"Practical takeaway","text":"<p>Use: - <code>VerlindeModularData(\"A\",1,4)</code> for <code>SU(2)_4</code>. - <code>CyclicPointedFusionRing(5)</code> for <code>SU(5)_1</code>. - <code>GetModularData(5, iGO, iMD)</code> for all rank-5 modular data, including the   quotient families.</p>"},{"location":"guide/rank5_table.generated/","title":"I  fusionrings package is not available. Check that the name is correct","text":""},{"location":"guide/rank5_table.generated/#i-and-it-is-present-in-one-of-the-gap-root-directories-see-rootpaths","title":"I  and it is present in one of the GAP root directories (see '??RootPaths')","text":"<p>\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m\u001b[1m\u001b[34m\u001b[0m\u001b[31m</p>"},{"location":"guide/roadmap/","title":"Roadmap","text":""},{"location":"guide/roadmap/#done","title":"Done","text":"<ul> <li>ModularData object and reconstruction from database records.</li> <li>Validation levels 1 to 7.</li> <li>Rank &lt;= 12 database loader and getter helpers.</li> <li>Fusion ring bridge from modular data.</li> <li>Phase 2 kickoff: SU(2)_k via <code>VerlindeModularData(\"A\", 1, k)</code>.</li> <li>New automated test: <code>pkg/FusionRings/tst/test_verlinde_su2.tst</code>.</li> </ul>"},{"location":"guide/roadmap/#next-targets","title":"Next targets","text":"<ol> <li>Type A rank &gt; 1 (SU(n+1)_k) via Weyl-group formulas.</li> <li><code>VerlindeModularDataByLieAlgebra</code> and <code>...ByRootSystem</code> implementations.</li> <li>Extra tests for SU(3)_k and broader level sweeps.</li> <li>Optional zesting layer after original data constructors are stable.</li> </ol>"},{"location":"guide/theorem-to-computation/","title":"Theorem to Computation","text":"<p>This guide translates common statements from the papers into concrete GAP commands you can run with FusionRings.</p> <p>Start with:</p> <pre><code>LoadPackage(\"FusionRings\");;\n</code></pre>"},{"location":"guide/theorem-to-computation/#1-fusion-ring-axioms-and-structure-constants","title":"1) Fusion ring axioms and structure constants","text":"<p>Theory view: a based ring (fusion ring) has nonnegative integral structure constants and distinguished basis/identity.</p> <pre><code>F := IsingFusionRing();;\nCheckFusionRingAxioms(F, 2);\nMultiplyBasis(F, \"sigma\", \"sigma\");\n</code></pre> <p>Expected:</p> <pre><code>true\n[ [ \"1\", 1 ], [ \"psi\", 1 ] ]\n</code></pre>"},{"location":"guide/theorem-to-computation/#2-perron-frobenius-dimensions-and-global-fp-dimension","title":"2) Perron-Frobenius dimensions and global FP dimension","text":"<p>Theory view: each simple has FP dimension; global dimension is <code>sum_i d_i^2</code>.</p> <pre><code>Ffib := FibonacciFusionRing();;\nFPDimensionPolynomial(Ffib, \"x\");\nFPDimensions(Ffib);\nGlobalFPDimension(Ffib);\n</code></pre> <p>Expected:</p> <pre><code>x_1^2-x_1-1\n[ 1, fp2 ]\nfp2+2\n</code></pre>"},{"location":"guide/theorem-to-computation/#3-invertibles-pointed-subring-adjoint-subring","title":"3) Invertibles, pointed subring, adjoint subring","text":"<p>Theory view: invertibles form a canonical pointed fusion subring; the adjoint subring is generated by <code>X tensor X*</code>.</p> <pre><code>Fi := IsingFusionRing();;\nInvertibleSimples(Fi);\nLabelsList(CanonicalPointedSubring(Fi));\nLabelsList(AdjointSubring(Fi));\n</code></pre> <p>Expected:</p> <pre><code>[ \"1\", \"psi\" ]\n[ \"1\", \"psi\" ]\n[ \"1\", \"psi\" ]\n</code></pre>"},{"location":"guide/theorem-to-computation/#4-universal-grading","title":"4) Universal grading","text":"<p>Theory view: every fusion ring admits universal grading with neutral component equal to adjoint part.</p> <pre><code>UG := UniversalGradingData(Fi);;\nUniversalGradingOrder(Fi);\nUniversalGradingComponent(Fi, \"1\");\nUniversalGradingComponent(Fi, \"sigma\");\nUG.multiplication;\n</code></pre> <p>Expected:</p> <pre><code>2\n1\n2\n[ [ 1, 2 ], [ 2, 1 ] ]\n</code></pre>"},{"location":"guide/theorem-to-computation/#5-paper-style-criteria-commutative-case","title":"5) Paper-style criteria (commutative case)","text":"<p>Theory view: d-number / Drinfeld / cyclotomic-type filters.</p> <pre><code>F4 := CyclicPointedFusionRing(4);;\nCheckPaperCriteriaCommutative(F4);\n</code></pre> <p>Interpretation: - <code>dNumber.ok=true</code> is an exact implemented pass/fail. - <code>drinfeld</code> and <code>cyclotomic</code> can return conservative <code>applicable=false</code> on   inputs requiring deeper exact field checks.</p>"},{"location":"guide/theorem-to-computation/#6-from-su2_k-theorem-to-ade-module-graphs","title":"6) From SU(2)_k theorem to ADE module graphs","text":"<p>Theory view (Ostrik): module categories over <code>SU(2)_k</code> correspond to ADE data.</p> <pre><code>mods10 := OstrikSU2Modules(10);;\nList(mods10, x -&gt; x.type);\nM := mods10[3].module;;    # E6 at k=10\nIsOstrikSU2Module(M, 10, \"E6\");\n</code></pre> <p>Expected:</p> <pre><code>[ \"A\", \"D\", \"E6\" ]\ntrue\n</code></pre>"},{"location":"guide/theorem-to-computation/#7-from-module-graph-to-publication-ready-figure","title":"7) From module graph to publication-ready figure","text":"<pre><code>M4 := OstrikSU2Module(4, \"D\");;\nSaveFusionModuleGraphDOT(\"nimrep_d4.dot\", M4, LabelOfPosition(UnderlyingFusionRing(M4), 2));\nSaveFusionModuleGraphSVG(\"nimrep_d4.svg\", M4, LabelOfPosition(UnderlyingFusionRing(M4), 2));\n</code></pre> <p>Notes: - DOT is always available. - SVG generation uses Graphviz <code>dot</code> if installed.</p>"},{"location":"guide/theorem-to-computation/#8-full-theorem-to-computation-smoke-run","title":"8) Full theorem-to-computation smoke run","text":"<pre><code>LoadPackage(\"FusionRings\");;\nF := FusionRingFromModularData(GetModularData(2, 1, 1));;\nCheckFusionRingAxioms(F, 1);\nOstrikReport(10);\n</code></pre> <p>This closes the loop from modular data to fusion ring to ADE-module report.</p>"},{"location":"guide/validation-levels/","title":"Validation Levels","text":"<p><code>ValidateModularData(md, level)</code> performs incremental checks.</p> <p>Validation is cumulative: level <code>n</code> includes checks from levels <code>1..n</code>.</p> <p>Think of levels as \"how strict should I be right now?\": - Levels <code>1-3</code>: fast structural screening. - Level <code>4</code>: strong consistency checkpoint (good default in practice). - Levels <code>5-7</code>: deeper arithmetic/Galois-style filters.</p>"},{"location":"guide/validation-levels/#level-by-level-details","title":"Level-by-level details","text":"<ol> <li>Shape and basic matrix constraints</li> <li><code>S</code> is square and symmetric.</li> <li><code>S * S^t = D^2 I</code>.</li> <li><code>T</code> is diagonal.</li> <li>Modular/Gauss relations</li> <li>Gauss sums <code>p_+</code>, <code>p_-</code> satisfy <code>p_+ p_- = D^2</code>.</li> <li><code>(ST)^3 = p_+ S^2</code>.</li> <li><code>p_+/p_-</code> root-of-unity check (when available).</li> <li>Verlinde coefficients</li> <li>If stored <code>N</code> exists: checks exact match with Verlinde formula.</li> <li>If <code>N</code> is absent: checks computed coefficients are nonnegative integers.</li> <li>Balancing equation</li> <li>Verifies <code>S_{ij}</code> reconstruction from <code>N</code>, twists, and dimensions.</li> <li>Frobenius-Schur indicators</li> <li>Checks <code>nu_2</code> constraints on self-dual / non-self-dual simples.</li> <li>Field and Galois structure (partial implementation)</li> <li>Cyclotomic containment checks for entries of <code>S</code>, <code>T</code>.</li> <li>Column permutation under Galois action (up to sign), when available.</li> <li>Cauchy prime check</li> <li>Compares primes dividing <code>ord(T)</code> and <code>D^2</code> (or <code>Norm(D^2)</code> fallback).</li> </ol>"},{"location":"guide/validation-levels/#typical-usage","title":"Typical usage","text":"<pre><code>v := ValidateModularData(md, 4);\nif not v.ok then\n  Print(v.failures, \"\\n\");\nfi;\n</code></pre> <p>Suggested defaults: - during exploration: level <code>4</code>; - before claims/paper tables: level <code>7</code>.</p>"},{"location":"guide/validation-levels/#full-walkthrough-on-rank-2-and-rank-3-database-entries","title":"Full walkthrough on rank-2 and rank-3 database entries","text":"<pre><code>LoadPackage(\"FusionRings\");;\n\n# Rank 2 example\nmd2 := GetModularData(2, 1, 1);;\nfor l in [1..7] do\n  v := ValidateModularData(md2, l);;\n  Print(\"rank2 level \", l, \": ok=\", v.ok, \", failures=\", Length(v.failures), \"\\n\");\nod;\n\n# Rank 3 example (first level-4-valid entry found in the database)\nmd3 := GetModularData(3, 2, 1);;\nfor l in [1..7] do\n  v := ValidateModularData(md3, l);;\n  Print(\"rank3 (2,1) level \", l, \": ok=\", v.ok, \", failures=\", Length(v.failures), \"\\n\");\nod;\n</code></pre> <p>Expected behavior for these examples: all levels return <code>ok=true</code>.</p> <p>Reading the output: - <code>ok=true, failures=0</code> means the entry passed all checks up to that level; - if a level fails, inspect <code>v.failures</code> and stop before bridge/construction steps.</p>"},{"location":"guide/validation-levels/#reproducible-test-command-entire-package","title":"Reproducible test command (entire package)","text":"<p>To verify that all validation-related tests pass together with the rest of the package:</p> <pre><code>LoadPackage(\"FusionRings\");;\nFusionRings_TestAllStrict();\n</code></pre> <p>Recent run status on this repository: - <code>0 failures in 27 files</code> - <code>No errors detected while testing</code></p>"}]}