# Theorem to Computation

This guide translates common statements from the papers into concrete GAP
commands you can run with FusionRings.

Start with:

```gap
LoadPackage("FusionRings");;
```

## 1) Fusion ring axioms and structure constants

Theory view: a based ring (fusion ring) has nonnegative integral structure
constants and distinguished basis/identity.

```gap
F := IsingFusionRing();;
CheckFusionRingAxioms(F, 2);
MultiplyBasis(F, "sigma", "sigma");
```

Expected:

```text
true
[ [ "1", 1 ], [ "psi", 1 ] ]
```

## 2) Perron-Frobenius dimensions and global FP dimension

Theory view: each simple has FP dimension; global dimension is `sum_i d_i^2`.

```gap
Ffib := FibonacciFusionRing();;
FPDimensionPolynomial(Ffib, "x");
FPDimensions(Ffib);
GlobalFPDimension(Ffib);
```

Expected:

```text
x_1^2-x_1-1
[ 1, fp2 ]
fp2+2
```

## 3) Invertibles, pointed subring, adjoint subring

Theory view: invertibles form a canonical pointed fusion subring; the adjoint
subring is generated by `X tensor X*`.

```gap
Fi := IsingFusionRing();;
InvertibleSimples(Fi);
LabelsList(CanonicalPointedSubring(Fi));
LabelsList(AdjointSubring(Fi));
```

Expected:

```text
[ "1", "psi" ]
[ "1", "psi" ]
[ "1", "psi" ]
```

## 4) Universal grading

Theory view: every fusion ring admits universal grading with neutral component
equal to adjoint part.

```gap
UG := UniversalGradingData(Fi);;
UniversalGradingOrder(Fi);
UniversalGradingComponent(Fi, "1");
UniversalGradingComponent(Fi, "sigma");
UG.multiplication;
```

Expected:

```text
2
1
2
[ [ 1, 2 ], [ 2, 1 ] ]
```

## 5) Paper-style criteria (commutative case)

Theory view: d-number / Drinfeld / cyclotomic-type filters.

```gap
F4 := CyclicPointedFusionRing(4);;
CheckPaperCriteriaCommutative(F4);
```

Interpretation:
- `dNumber.ok=true` is an exact implemented pass/fail.
- `drinfeld` and `cyclotomic` can return conservative `applicable=false` on
  inputs requiring deeper exact field checks.

## 6) From SU(2)_k theorem to ADE module graphs

Theory view (Ostrik): module categories over `SU(2)_k` correspond to ADE data.

```gap
mods10 := OstrikSU2Modules(10);;
List(mods10, x -> x.type);
M := mods10[3].module;;    # E6 at k=10
IsOstrikSU2Module(M, 10, "E6");
```

Expected:

```text
[ "A", "D", "E6" ]
true
```

## 7) From module graph to publication-ready figure

```gap
M4 := OstrikSU2Module(4, "D");;
SaveFusionModuleGraphDOT("nimrep_d4.dot", M4, LabelOfPosition(UnderlyingFusionRing(M4), 2));
SaveFusionModuleGraphSVG("nimrep_d4.svg", M4, LabelOfPosition(UnderlyingFusionRing(M4), 2));
```

Notes:
- DOT is always available.
- SVG generation uses Graphviz `dot` if installed.

## 8) Full theorem-to-computation smoke run

```gap
LoadPackage("FusionRings");;
F := FusionRingFromModularData(GetModularData(2, 1, 1));;
CheckFusionRingAxioms(F, 1);
OstrikReport(10);
```

This closes the loop from modular data to fusion ring to ADE-module report.
