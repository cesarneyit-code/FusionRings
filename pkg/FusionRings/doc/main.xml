<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Book SYSTEM "gapdoc.dtd">
<Book Name="FusionRings">
  <TitlePage>
    <Title>FusionRings</Title>
    <Subtitle>Fusion rings as GAP objects</Subtitle>
    <Version>0.1.0</Version>
    <Date>2026-02-01</Date>
  </TitlePage>

  <TableOfContents/>

  <Body>
    <Chapter Label="intro">
      <Heading>Introduction</Heading>
      <Section>
        <Heading>Overview</Heading>
        <P/>

          FusionRings provides GAP objects representing fusion rings with
          label-based APIs, multiple internal representations, and validation
          utilities.
        
      </Section>
      <Section>
        <Heading>Installation and Loading</Heading>
        <P/>

          If the package is installed in a GAP package directory, load it via
          <C>LoadPackage("FusionRings")</C>.
        
        <P/>

          For direct loading without GAP's package mechanism, use the helper
          loader in <C>read_direct.g</C>:
        
        <Listing Type="Gap">
Read("/Users/cesargalindo/Documents/FusionRings/read_direct.g");
        </Listing>
      </Section>
      <Section>
        <Heading>Quick Start</Heading>
        <Listing Type="Gap">
G := Group((1,2,3));;
F := PointedFusionRing(G);;
MultiplyBasis(F, (1,2,3), (1,2,3));
FusionRings_TestAllStrict();
Display(F);
        </Listing>
        <P/>
Example output:
        <Listing Type="plain">
FusionRing
  rep: rule
  rank: 3
  one: ()
  labels: [ (), (1,2,3), (1,3,2) ]
        </Listing>
      </Section>
    </Chapter>

    <Chapter Label="api">
      <Heading>API</Heading>
      <Section>
        <Heading>Constructors</Heading>
        <ManSection>
          <Func Name="FusionRing" Arg="I, one, dual, multOrData, opts"/>
          <Func Name="FusionRingByRule" Arg="I, one, dual, mult, opts"/>
          <Func Name="FusionRingBySparseConstants" Arg="I, one, dual, prodTable, opts"/>
          <Func Name="FusionRingByFusionMatrices" Arg="labels, one, dual, fusionMatrices, opts"/>
          <Func Name="PointedFusionRing" Arg="G"/>
          <Func Name="CyclicPointedFusionRing" Arg="n"/>
          <Func Name="FibonacciFusionRing" Arg=""/>
          <Func Name="IsingFusionRing" Arg=""/>
          <Func Name="TambaraYamagamiFusionRing" Arg="A"/>
          <Func Name="NearGroupFusionRing" Arg="G, k"/>
          <Attr Name="TYMLabel" Arg="F"/>
          <Attr Name="NGRhoLabel" Arg="F"/>
          <Description>
            Constructors for fusion rings and the pointed fusion ring of a group.
            See also <Ref Func="PointedFusionRing"/>.
          </Description>
        </ManSection>
      </Section>
      <Section>
        <Heading>Core Operations</Heading>
        <ManSection>
          <Oper Name="MultiplyBasis" Arg="F, i, j"/>
          <Oper Name="FusionCoefficient" Arg="F, i, j, k"/>
          <Oper Name="DualLabel" Arg="F, i"/>
          <Oper Name="FusionMatrix" Arg="F, i"/>
          <Oper Name="IsInvertibleSimple" Arg="F, i"/>
          <Attr Name="InvertibleSimples" Arg="F"/>
          <Prop Name="IsPointedFusionRing" Arg="F"/>
          <Oper Name="IsFusionSubring" Arg="F, subset"/>
          <Oper Name="FusionSubring" Arg="F, subset"/>
          <Func Name="FusionSubringByGenerators" Arg="F, generators"/>
          <Func Name="FusionSubringLatticeSmall" Arg="F[, maxRank]"/>
          <Attr Name="CanonicalPointedSubring" Arg="F"/>
          <Attr Name="AdjointSubring" Arg="F"/>
          <Prop Name="IsIntegralFusionRing" Arg="F"/>
          <Prop Name="IsWeaklyIntegralFusionRing" Arg="F"/>
          <Func Name="CheckDNumberCriterionCommutative" Arg="F"/>
          <Func Name="CheckDrinfeldCriterionCommutative" Arg="F"/>
          <Func Name="CheckExtendedCyclotomicCriterionCommutative" Arg="F"/>
          <Func Name="CheckPaperCriteriaCommutative" Arg="F"/>
          <Oper Name="CheckFusionRingAxioms" Arg="F, level"/>
          <Func Name="CheckFusionRingAxiomsSample" Arg="F, level, samples"/>
          <Description>
            Basic algebraic operations and verification. See
            <Ref Oper="MultiplyBasis"/> and <Ref Oper="CheckFusionRingAxioms"/>.
          </Description>
        </ManSection>
      </Section>
      <Section>
        <Heading>Based Modules (Fusion Modules)</Heading>
        <ManSection>
          <Func Name="FusionModuleByActionMatrices" Arg="F, basisLabels, actionMatrices[, opts]"/>
          <Attr Name="UnderlyingFusionRing" Arg="M"/>
          <Attr Name="ModuleBasisLabels" Arg="M"/>
          <Attr Name="ModuleRank" Arg="M"/>
          <Attr Name="ActionMatrices" Arg="M"/>
          <Oper Name="ActionMatrix" Arg="M, i"/>
          <Oper Name="ActionOnBasis" Arg="M, i, m"/>
          <Oper Name="IsFusionSubmodule" Arg="M, subset"/>
          <Oper Name="FusionSubmodule" Arg="M, subset"/>
          <Func Name="FusionSubmoduleByGenerators" Arg="M, generators"/>
          <Attr Name="FusionModuleComponents" Arg="M"/>
          <Prop Name="IsIndecomposableFusionModule" Arg="M"/>
          <Prop Name="IsIrreducibleFusionModule" Arg="M"/>
          <Oper Name="AreEquivalentFusionModules" Arg="M1, M2"/>
          <Func Name="FusionModuleGraph" Arg="M[, i]"/>
          <Attr Name="CanonicalFusionModule" Arg="F"/>
          <Oper Name="FusionSubmoduleByObject" Arg="F, i"/>
          <Func Name="DynkinGraphAdjacency" Arg="type[, n]"/>
          <Func Name="OstrikSU2Module" Arg="k, type[, n][, opts]"/>
          <Func Name="OstrikSU2Modules" Arg="k"/>
          <Func Name="IsOstrikSU2Module" Arg="M, k[, type[, n]]"/>
          <Func Name="NimrepFromModule" Arg="M[, i]"/>
          <Func Name="GraphSpectrumApprox" Arg="A|M|nimrep"/>
          <Func Name="CoxeterNumberFromAdjacencyApprox" Arg="A|M|nimrep"/>
          <Func Name="IsADELevelCompatible" Arg="k, type[, n]"/>
          <Func Name="CheckOstrikADEData" Arg="k, type[, n]"/>
          <Func Name="FusionModuleGraphDOT" Arg="graph|M[, i]"/>
          <Func Name="SaveFusionModuleGraphDOT" Arg="path, graph|M[, i]"/>
          <Func Name="OstrikReport" Arg="k"/>
          <Description>
            Based-module constructors and analysis tools over a fusion ring.
          </Description>
        </ManSection>
      </Section>
      <Section>
        <Heading>Attributes and Indexing</Heading>
        <ManSection>
          <Attr Name="BasisLabels" Arg="F"/>
          <Attr Name="OneLabel" Arg="F"/>
          <Attr Name="DualData" Arg="F"/>
          <Attr Name="RepresentationType" Arg="F"/>
          <Attr Name="LabelsList" Arg="F"/>
          <Attr Name="DualTable" Arg="F"/>
          <Attr Name="FusionMatrices" Arg="F"/>
          <Attr Name="FPDimensionData" Arg="F"/>
          <Attr Name="FPRank" Arg="F"/>
          <Attr Name="GlobalFPDimension" Arg="F"/>
          <Attr Name="FPType" Arg="F"/>
          <Attr Name="FPDimensions" Arg="F"/>
          <Attr Name="FPDimensionPolynomials" Arg="F"/>
          <Attr Name="FormalCodegrees" Arg="F"/>
          <Oper Name="FPDimensionPolynomial" Arg="F, i"/>
          <Oper Name="FPDimensionApprox" Arg="F, i[, digits]"/>
          <Func Name="FPDimensionsApprox" Arg="F[, digits]"/>
          <Func Name="FPTypeApprox" Arg="F[, digits]"/>
          <Oper Name="PositionOfLabel" Arg="F, i"/>
          <Oper Name="LabelOfPosition" Arg="F, p"/>
          <Func Name="NormalizeProductList" Arg="list[, F]"/>
          <Description>
            Accessors and helpers for label sets, indexing, dual tables, and
            fusion matrices.
          </Description>
        </ManSection>
      </Section>
      <Section>
        <Heading>Testing Helpers</Heading>
        <ManSection>
          <Func Name="FusionRings_TestAll" Arg=""/>
          <Func Name="FusionRings_TestAllStrict" Arg=""/>
          <Func Name="FusionRings_RewriteTests" Arg=""/>
          <Description>
            Convenience wrappers for running and normalizing the package tests.
          </Description>
        </ManSection>
      </Section>
      <Section>
        <Heading>Export / Import</Heading>
        <ManSection>
          <Func Name="FusionRingRecord" Arg="F"/>
          <Func Name="FusionRingFromRecord" Arg="rec"/>
          <Func Name="SaveFusionRing" Arg="filename, F"/>
          <Func Name="LoadFusionRing" Arg="filename"/>
          <Description>
            Serialize and restore fusion rings in a GAP record format.
            Rule-based representations are not serializable.
          </Description>
        </ManSection>
      </Section>
      <Section>
        <Heading>Options</Heading>
        <P/>

          Constructors accept an optional record <C>opts</C> with fields:
        
        <List>
          <Item><C>storeRepresentation</C>: "rule", "sparse", or "matrices".</Item>
          <Item><C>check</C>: 0, 1, or 2 (verification level).</Item>
          <Item><C>inferDual</C>: true/false to infer the dual when possible.</Item>
          <Item><C>buildIndex</C>: true/false to build a labels index.</Item>
          <Item><C>makeImmutable</C>: true/false to finalize as immutable.</Item>
        </List>
      </Section>

      <Section>
        <Heading>ModularData (Quick API)</Heading>
        <ManSection>
          <Func Name="ModularData" Arg="rec | S, T[, labels]"/>
          <Func Name="ModularDataFromNsdRecord" Arg="rec"/>
          <Func Name="ModularDataFromST" Arg="S, T[, labels]"/>
          <Func Name="ValidateModularData" Arg="md[, level]"/>
          <Func Name="LoadNsdGOL" Arg="rank"/>
          <Func Name="GetModularData" Arg="rank, iGO, iMD"/>
          <Func Name="FusionRingFromModularData" Arg="md"/>
          <Func Name="VerlindeModularData" Arg="type, rank, level"/>
          <Func Name="VerlindeModularDataByLieAlgebra" Arg="L, level"/>
          <Func Name="VerlindeModularDataByRootSystem" Arg="R, level"/>
          <Attr Name="SMatrix" Arg="md"/>
          <Attr Name="TMatrix" Arg="md"/>
          <Attr Name="MDLabels" Arg="md"/>
          <Attr Name="MDSpins" Arg="md"/>
          <Attr Name="MDTwists" Arg="md"/>
          <Attr Name="MDQuantumDimensions" Arg="md"/>
          <Attr Name="MDGlobalDimensionSquared" Arg="md"/>
          <Attr Name="MDFusionCoefficients" Arg="md"/>
          <Attr Name="MDOrderT" Arg="md"/>
          <Description>
            Modular data support (rank ≤ 12 database, reconstruction via balancing
            equation, and validation levels 1–7). Verlinde constructors are
            planned; currently <C>VerlindeModularData("A", 1, k)</C> implements
            SU(2)_k. See the full technical guide in <C>doc/modular_data.md</C>.
          </Description>
        </ManSection>
      </Section>
    </Chapter>

    <Chapter Label="formats">
      <Heading>Data Formats</Heading>
      <Section>
        <Heading>Product Lists</Heading>
        <P/>

          The product <C>i*j</C> is represented as a list of pairs
          <C>[[k1,n1],[k2,n2],...]</C> with integer coefficients <C>ni &gt;= 0</C>.
          The helper <C>NormalizeProductList</C> combines repeated terms and
          removes zeros.
        
      </Section>
      <Section>
        <Heading>Sparse Table</Heading>
        <P/>

          The sparse table can be given as a list of triples
          <C>[i, j, productList]</C>, or as a record keyed by pairs. See examples
          in the tests.
        
      </Section>
    </Chapter>

    <Chapter Label="reps">
      <Heading>Representations and Performance</Heading>
      <Section>
        <Heading>Representations</Heading>
        <List>
          <Item><C>rule</C>: multiplication by function; minimal storage.</Item>
          <Item><C>sparse</C>: explicit sparse products per pair.</Item>
          <Item><C>matrices</C>: fusion matrices <C>N_i</C> stored explicitly.</Item>
        </List>
      </Section>
      <Section>
        <Heading>Performance Tips</Heading>
        <List>
          <Item>For large objects, prefer <C>sparse</C> or <C>matrices</C>.</Item>
          <Item>Disable heavy checks with <C>check := 0</C> and use on-demand validation.</Item>
          <Item>Keep <C>buildIndex := true</C> for faster label lookup.</Item>
          <Item>Use <C>FusionMatrix</C> only when needed to avoid large allocations.</Item>
        </List>
      </Section>
      <Section>
        <Heading>Printing</Heading>
        <P/>

          Fusion rings have custom <C>ViewObj</C> and <C>PrintObj</C>
          output to show representation, rank, and labels.
        
      </Section>
    </Chapter>

    <Chapter Label="verification">
      <Heading>Verification Levels</Heading>
      <Section>
        <Heading>CheckFusionRingAxioms</Heading>
        <P/>

          Levels:
        
        <List>
          <Item><C>0</C>: internal consistency only (fast).</Item>
          <Item><C>1</C>: unit, involution, Frobenius reciprocity, and basic dual checks.</Item>
          <Item><C>2</C>: full associativity and Frobenius checks (expensive).</Item>
        </List>
        <P/>

          For large rings, run level 0 or 1 during construction and reserve level 2
          for small examples or dedicated validation runs.
        
      </Section>
      <Section>
        <Heading>Sampled Checks</Heading>
        <P/>
        For large rings you may use <C>CheckFusionRingAxiomsSample</C> to test
        randomly selected triples of labels.
        <Listing Type="Gap">
CheckFusionRingAxiomsSample(F, 2, 100);
        </Listing>
      </Section>
    </Chapter>

    <Chapter Label="design">
      <Heading>Design Decisions</Heading>
      <Section>
        <Heading>Labels and Duality</Heading>
        <List>
          <Item>All public APIs use labels from <C>I</C>, not integer indices.</Item>
          <Item>Duality is stored as part of the object and is always available.</Item>
        </List>
      </Section>
      <Section>
        <Heading>Immutability and Caches</Heading>
        <List>
          <Item>Objects are immutable after construction.</Item>
          <Item>Derived data (dual table, matrices, labels list) are cached via attributes.</Item>
        </List>
      </Section>
      <Section>
        <Heading>Multiple Representations</Heading>
        <List>
          <Item>Rule-based, sparse, and matrices representations share one public API.</Item>
          <Item>Internal indexing is optional and used for performance.</Item>
        </List>
      </Section>
    </Chapter>

    <Chapter Label="roadmap">
      <Heading>Limitations and Roadmap</Heading>
      <Section>
        <Heading>Current Limitations</Heading>
        <List>
          <Item>No modular data (S/T matrices) in this version.</Item>
          <Item>Minimal pretty-printing; focus is on core algebra.</Item>
          <Item>Associativity checks at level 2 can be expensive for large rings.</Item>
        </List>
      </Section>
      <Section>
        <Heading>Planned Extensions</Heading>
        <List>
          <Item>Modular data and categorical invariants.</Item>
          <Item>Serialization/import/export tools.</Item>
          <Item>Enhanced docs and examples.</Item>
        </List>
      </Section>
    </Chapter>

    <Chapter Label="testing">
      <Heading>Testing</Heading>
      <Section>
        <Heading>Running Tests</Heading>
        <P/>

          After loading via <C>read_direct.g</C>, use:
        
        <Listing Type="Gap">
FusionRings_TestAll();
        </Listing>
        <P/>

          This runs all <C>.tst</C> files in the package test directory.
        
        <P/>

          For strict checking and normalized outputs:
        
        <Listing Type="Gap">
FusionRings_RewriteTests();   # normalize outputs once per GAP install
FusionRings_TestAllStrict();  # strict (ignores newline-only diffs)
        </Listing>
      </Section>
      <Section>
        <Heading>Test Suite Contents</Heading>
        <List>
          <Item><C>tst/test_pointed.tst</C>: pointed fusion ring basics.</Item>
          <Item><C>tst/test_sparse.tst</C>: sparse representation (Z/2 example).</Item>
          <Item><C>tst/test_matrices.tst</C>: matrices representation (Z/2 example).</Item>
          <Item><C>tst/test_axioms2.tst</C>: level-2 axioms on small cases.</Item>
          <Item><C>tst/test_families.tst</C>: Fibonacci/Ising/TY/cyclic constructors.</Item>
          <Item><C>tst/test_neargroup.tst</C>: near-group (G+k) rules.</Item>
          <Item><C>tst/test_export.tst</C>: save/load roundtrip.</Item>
          <Item><C>tst/test_export_matrices.tst</C>: save/load roundtrip (matrices).</Item>
        </List>
      </Section>
    </Chapter>

    <Chapter Label="documentation">
      <Heading>Building Documentation</Heading>
      <Section>
        <Heading>Manual Build</Heading>
        <P/>

          If GAP is available, build the manual by reading:
        
        <Listing Type="Gap">
Read("/Users/cesargalindo/Documents/FusionRings/pkg/FusionRings/doc/build_manual.g");
        </Listing>
        <P/>

          This generates <C>manual.six</C>, <C>chap0.html</C>, and <C>manual.pdf</C>
          (PDF requires a TeX installation).
        
      </Section>
    </Chapter>

    <Chapter Label="examples">
      <Heading>Examples</Heading>
      <Section>
        <Heading>Z/2Z Pointed Ring</Heading>
        <Listing Type="Gap">
labels := [ "1", "x" ];;
prodTable := [
  [ "1", "1", [ [ "1", 1 ] ] ],
  [ "1", "x", [ [ "x", 1 ] ] ],
  [ "x", "1", [ [ "x", 1 ] ] ],
  [ "x", "x", [ [ "1", 1 ] ] ]
];;
F := FusionRingBySparseConstants(labels, "1", [ "1", "x" ], prodTable, rec(check := 1));;
MultiplyBasis(F, "x", "x");
        </Listing>
      </Section>
      <Section>
        <Heading>Fibonacci and Ising</Heading>
        <Listing Type="Gap">
F := FibonacciFusionRing();;
MultiplyBasis(F, "x", "x");
F := IsingFusionRing();;
MultiplyBasis(F, "sigma", "sigma");
        </Listing>
      </Section>
      <Section>
        <Heading>Pointed Cyclic</Heading>
        <Listing Type="Gap">
F := CyclicPointedFusionRing(4);;
CheckFusionRingAxioms(F, 1);
        </Listing>
      </Section>
      <Section>
        <Heading>Near-group (G + k)</Heading>
        <Listing Type="Gap">
G := CyclicGroup(3);;
F := NearGroupFusionRing(G, 1);;
rho := NGRhoLabel(F);;
MultiplyBasis(F, rho, rho);
        </Listing>
      </Section>
      <Section>
        <Heading>Tambara–Yamagami</Heading>
        <Listing Type="Gap">
A := CyclicGroup(3);;
F := TambaraYamagamiFusionRing(A);;
m := TYMLabel(F);;
m &lt;&gt; fail;
MultiplyBasis(F, m, m);
CheckFusionRingAxioms(F, 1);
        </Listing>
      </Section>
    </Chapter>
  </Body>
</Book>
