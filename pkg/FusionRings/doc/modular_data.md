# Modular Data in FusionRings

This document is the single source of truth for the **ModularData** module:
- mathematical specification (admissible modular data),
- database format (NsdGOL),
- API and validation levels,
- tests and usage examples.

It is intended to remain within the FusionRings package and to be integrated
into GAPDoc later if desired.

---

## 1) Admissible Modular Data (specification)

We fix one notion of modular data: **admissible modular data**. A pair `(S,T)` is
admissible if it satisfies (i)–(vii) below. Indices are `1..r` in GAP, with unit
object at index `1`.

### Data and notation

- `r >= 1` is the **rank** (number of labels/simples).
- `S, T in GL_r(C)`.
- `T` is **diagonal**: `T_ij = delta_ij * theta_i`, `theta_i in C^*`.
- **Quantum dimensions**: `d_i := S_{1,i}`.
- **Global dimension (squared)**: `D^2 := sum_i d_i^2`.
- `N := ord(T)` is finite (all `theta_i` are roots of unity).

### (i) Symmetry/orthogonality of `S`; diagonal and finite order `T`

1. `S = S^t`.
2. `S * S^t = D^2 * I_r` (equivalently `S^{-1} = (1/D^2) * S^t`).
3. `T` is diagonal.
4. `ord(T) < infinity`.

### (ii) Modular equation and Gauss sums

Define **Gauss sums**:

```
p_+ := sum_k d_k^2 * theta_k
p_- := sum_k d_k^2 * theta_k^{-1}
```

Require:

1. `(S*T)^3 = p_+ * S^2`.
2. `p_+ * p_- = D^2`.
3. `p_+ / p_-` is a root of unity.

### (iii) Verlinde formula and integrality

```
N^k_ij := (1/D^2) * sum_a (S_{i a} * S_{j a} * S_{k a}) / S_{1 a}
```

Require `N^k_ij in N` for all `i,j,k`.

### (iv) Duality and balancing equation

Define dual `i*` by `N^1_{i,i*} = 1`. Require the **balancing equation**:

```
S_{i j} = sum_k N^k_{i j} * (theta_i * theta_j / theta_k) * d_k
```

### (v) Frobenius–Schur (FS) indicators

For `n >= 1`:

```
nu_n(k) := (1/D^2) * sum_{i,j} N^k_ij * d_i * d_j * (theta_i / theta_j)^n
```

Require:
- `nu_2(k) = 0` if `k != k*`.
- `nu_2(k) = ±1` if `k = k*`.
- `nu_n(k) in Z[e^{2 pi i / N}]` for all `n,k`.

### (vi) Fields and Galois symmetry (structural)

Let `F_T := Q_N` and `F_S` be the field generated by entries of `S`.
Require:
1. `F_S ⊆ F_T = Q_N`.
2. `Gal(F_S/Q)` acts by permuting labels (abelian subgroup of `S_r`).
3. `Gal(F_T/F_S) ≅ (Z/2Z)^ℓ`.

### (vii) Cauchy theorem (prime divisors)

The primes dividing `D^2` coincide with those dividing `N`.

---

## 2) Database format (NsdGOL)

The rank ≤ 12 database is stored as GAP records:

```
pkg/FusionRings/data/modular_data/NsdGOL2.g
pkg/FusionRings/data/modular_data/NsdGOL3.g
...
pkg/FusionRings/data/modular_data/NsdGOL12.g
```

Each file defines a global `NsdGOL` list of **Galois orbits**. For indices
`iGO` (orbit) and `iMD` (entry):

- `NsdGOL[iGO][iMD].Nij_k` = fusion coefficients `N^k_ij`.
- `NsdGOL[iGO][iMD].s` = spins `s_i` with `theta_i = exp(2 pi i s_i)`.
- `NsdGOL[iGO][iMD].d` = exact quantum dimensions.
- `NsdGOL[iGO][iMD].df` = floating approximations (debug only).

**Efficient reconstruction:** given `(N, s, d)`, build `theta` from `s`, then
reconstruct `S` using the balancing equation (no diagonalization).

### Rigidity vs. ambiguity (in terms of the database)

The database does **not** store `S` directly. This is intentional:

- If you only know the fusion rules `N` (or even `N` and `T`), the modular data
  is **not rigid**: you can permute labels, apply Galois conjugation, or change
  spherical structure, producing distinct (but related) modular data.
- The database resolves this by grouping entries into **Galois orbits**:
  `NsdGOL[iGO]` is one orbit, and `NsdGOL[iGO][iMD]` are the different members
  (each with its own `s` and `d`).
- Once you **choose an entry** (i.e. fix `N`, `s`, and `d`), the balancing
  equation determines `S` **uniquely** for that entry:

```
S_{ij} = sum_k N^k_{ij} * (theta_i * theta_j / theta_k) * d_k
```

So the ambiguity lives at the orbit level, while reconstruction is rigid at
the entry level.

---

## 2.1) Lie/Verlinde modular data (original, root systems)

The paper `galindo.tex` (Lie/root-system based construction) describes how to
build **original modular data** from Verlinde categories
`C(g, k)` (quantum groups at roots of unity). This is distinct from **zesting**
data (treated later in that paper). For the package, we currently target only
the **original** modular data.

Key ingredients (root-system formulation):

- Choose a simple Lie algebra `g` and level `k > 0`.
- Let `q = exp(pi i / (m (k + h^vee)))`, with `m` depending on the root system,
  and `h^vee` the dual Coxeter number.
- Simple objects are labeled by dominant weights in the Weyl alcove:
  `Irr(C(g,k)) = { lambda in P_+ : <lambda, Theta> <= k }`,
  where `Theta` is the highest root.
- The modular matrices are given by Weyl-group sums:
  - `S_{lambda,mu}` is a signed sum over the Weyl group `W` with phase
    `q^{2 < < w(lambda+rho), mu+rho > > }`, normalized by the `rho`–`rho` sum.
  - `T_{lambda,lambda} = q^{ < < lambda, lambda + 2 rho > > }`.

These formulas are the basis for root-system/Verlinde modular data. They are
the **input layer** for future constructors (root-system → `(S,T)` → `ModularData`).

Zesting (braided/ribbon zesting) is **not implemented yet**; it will be added
as a second layer on top of the original data once the cohomological parameter
handling is in place.

---

## 2.2) Planned API: root‑system / Verlinde constructors

The following API is planned for the **original** (root‑system based) modular
data from Verlinde categories. This is **not implemented yet**; it is the next
construction layer after the current database‑based pipeline.

### Proposed constructors

- `VerlindeModularData(type, rank, level)`
  - Example: `VerlindeModularData("A", 2, k)` for `SU(3)_k`.
- `VerlindeModularDataByLieAlgebra(L, level)`
  - `L` is a semisimple Lie algebra in GAP.
- `VerlindeModularDataByRootSystem(R, level)`
  - `R` is a root system in GAP.

These functions are currently **stubs** (they exist but raise a clear
`not implemented yet` error). This is intentional to make the future roadmap
visible in a fresh session.

**Status (Phase 2):**
- `VerlindeModularData("A", 1, k)` is implemented for SU(2)\_k (type A, rank 1).
- All other types/ranks remain unimplemented and still raise the stub error.

### Expected internal steps

1. Build the root system / Weyl group (`RootSystem`, `WeylGroup`).
2. Enumerate labels (dominant weights in the Weyl alcove).
3. Compute `S` and `T` from Weyl‑group formulas (BK Theorem 3.3.20).
4. Construct `ModularDataFromST(S, T, labels)` and validate.

### GAP helpers likely needed (from Chapter 64)

- `SimpleLieAlgebra`, `RootSystem`
- `WeylGroup`, `SparseCartanMatrix`, `ApplySimpleReflection`
- `DominantWeights`, `DominantCharacter` (for label enumeration)

Once this layer is implemented, it can feed into **zesting** as a second‑stage
modifier of modular data.

---

## 2.3) Implemented: SU(2)\_k (type A, rank 1)

This is the first implemented case of the Verlinde/root‑system layer. For
level `k >= 1`, the labels are `0..k`, and the S/T matrices are:

```
S_{a b} = ( q^{(a+1)(b+1)} - q^{-(a+1)(b+1)} ) / (q - q^{-1}),
q = exp(pi i / (k + 2)).

T_{a a} = exp( pi i * a(a+2) / (2(k+2)) ).
```

In GAP (cyclotomic form), this corresponds to:

- `q = E(2*(k+2))` and `T_{a a} = E(4*(k+2))^(a*(a+2))`.

Usage:

```
md := VerlindeModularData("A", 1, k);;
ValidateModularData(md, 4);
```

---

## FAQ

**Q: Why does the database not store the `S`-matrix?**  
A: Because for each database entry, `S` is uniquely determined from
`(N, s, d)` by the balancing equation. Storing `S` would duplicate data and
risk inconsistency.

**Q: Why are there multiple entries per rank / orbit?**  
A: Modular data is not rigid under Galois action. The database groups entries
into Galois orbits; each entry represents a distinct Galois conjugate (or a
change of spherical structure) with its own `s` and `d`.

**Q: If I only know `N`, can I reconstruct `S`?**  
A: Not uniquely. You must choose a specific entry (i.e. fix `s` and `d`) from
the database. Once you do, the balancing equation fixes `S` uniquely.

---

## 3) ModularData API

### Constructors

- `ModularData(rec)`
  - If `rec` is a database record with `Nij_k, s, d`, builds `S, T` via balancing.
- `ModularDataFromNsdRecord(rec)`
  - Same as above, explicit.
- `ModularDataFromST(S, T[, labels])`
  - Wraps an existing `(S,T)`.
  - Optional options record as last argument:
    - `inferN := true` tries to reconstruct fusion coefficients by Verlinde.
    - `completeData := true` fills `d`, `D2`, `theta`, `ordT` from `S`,`T`.

### Attributes

- `SMatrix(md)`
- `TMatrix(md)`
- `MDLabels(md)`
- `MDSpins(md)`
- `MDTwists(md)`
- `MDQuantumDimensions(md)`
- `MDGlobalDimensionSquared(md)`
- `MDFusionCoefficients(md)`
- `MDOrderT(md)`

### Database helpers

- `LoadNsdGOL(rank)`
  - Loads the database file for a given rank.
- `GetModularData(rank, iGO, iMD)`
  - Returns a `ModularData` object for the specified entry.
- `FusionRingFromModularData(md)`
  - Builds a `FusionRing` from the fusion coefficients stored in `md`.

---

## 4) Validation levels

`ValidateModularData(md, level)` returns a record with:

- `ok` (boolean)
- `failures` (list of strings)

Levels implemented:

- **1**: shape checks, symmetry, `S*S^t = D^2 I`, `T` diagonal.
- **2**: Gauss sums + modular equation.
- **3**: Verlinde consistency (against stored `N` or integrality check).
- **4**: balancing equation.
- **5**: FS indicator `nu_2` constraints.
- **6**: partial field/Galois checks:
  - entries in `Q_N` (via `Conductor` when available),
  - `Gal(Q_N)` permutes columns up to sign (via `GaloisMat` if available,
    otherwise `GaloisCyc`).

- **7**: Cauchy primes check using `Norm(D^2)` when available
  (falls back to rational case if `D^2` is rational).

### Practical walkthrough (rank 2 and rank 3)

```
Read("/Users/cesargalindo/Documents/FusionRings/read_direct.g");

md2 := GetModularData(2, 1, 1);;
for l in [1..7] do
  v := ValidateModularData(md2, l);;
  Print("rank2 level ", l, ": ok=", v.ok, ", failures=", Length(v.failures), "\n");
od;

md3 := GetModularData(3, 2, 1);;
for l in [1..7] do
  v := ValidateModularData(md3, l);;
  Print("rank3 (2,1) level ", l, ": ok=", v.ok, ", failures=", Length(v.failures), "\n");
od;
```

For these two entries, all levels `1..7` return `ok = true`.

### To do / Improvements

- **Level 6 (full)**: construct the exact field `F_S = Q(S_ij)` and verify
  `Gal(F_S/Q)` acts by permutations; check that `Gal(Q_N/F_S)` is a 2-group.
  Current level 6 is a practical partial check.
- **Level 7 (full)**: Cauchy primes via cyclotomic integer norms for all cases,
  independent of the availability of `Norm` or rationality shortcuts.

---

## 5) Tests

ModularData tests live in `pkg/FusionRings/tst/`:

- `test_modulardata_basic.tst`: construct from `NsdGOL2`, symmetry/orthogonality, diagonal `T`.
- `test_modulardata_verlinde.tst`: Verlinde reconstruction matches `N`.
- `test_modulardata_gauss.tst`: Gauss sums + `(ST)^3 = p_+ S^2`.
- `test_modulardata_fs.tst`: `nu_2` constraints.
- `test_modulardata_cauchy.tst`: Cauchy primes in rational case.
- `test_modulardata_validate*.tst`: validator levels 1–7.
- `test_modulardata_loader.tst`: database loader helpers.
- `test_modulardata_rank3.tst`: rank‑3 regression (level 4 + fusion ring axioms).
- `test_modulardata_rank4.tst`: rank‑4 regression (level 4 + fusion ring axioms).
- `test_modulardata_rank5.tst`: rank‑5 regression (level 4 + fusion ring axioms).

### Running tests

Run all tests (strict):

```
Read("/Users/cesargalindo/Documents/FusionRings/read_direct.g");
FusionRings_TestAllStrict();
```

Run a single test:

```
Read("/Users/cesargalindo/Documents/FusionRings/read_direct.g");
Test("/Users/cesargalindo/Documents/FusionRings/pkg/FusionRings/tst/test_modulardata_rank5.tst");
```

Run with tolerant comparison (newline quirks):

```
Read("/Users/cesargalindo/Documents/FusionRings/read_direct.g");
FusionRings_TestAll();
```

---

## 5.1) Cyclotomics cheat-sheet (GAP)

Useful functions for exact arithmetic and field checks:

- `E(n)`: primitive `n`-th root of unity.
- `IsCyclotomic(x)`: test cyclotomic.
- `IsIntegralCyclotomic(x)`: cyclotomic integer test.
- `Conductor(x)` / `Conductor(list)`: smallest `n` with `x in Q_n`.
- `DenominatorCyc(x)`: smallest `m` with `m*x` cyclotomic integer.
- `GaloisCyc(x, k)`: Galois conjugate by `k` (when `gcd(k,n)=1`).
- `GaloisMat(mat)`: Galois orbits and generators for rows of a cyclotomic matrix.
- `DefaultField(list)`: smallest cyclotomic field containing given elements.
- `Norm(x)`: field norm (used for Cauchy condition in level 7).

Performance note: cyclotomic arithmetic can be expensive at large conductors;
prefer aggregate checks (e.g., `Conductor(Flat(S))`) when possible.

## 6) Usage examples

### Load a database entry

```
LoadNsdGOL(2);
md := GetModularData(2, 1, 1);
S := SMatrix(md);
T := TMatrix(md);
ValidateModularData(md, 4);
```

### Build from a database record directly

```
Read("/Users/cesargalindo/Documents/FusionRings/pkg/FusionRings/data/modular_data/NsdGOL2.g");
md := ModularDataFromNsdRecord(NsdGOL[1][1]);
```

---

## 7) Implementation notes

- **Exact arithmetic**: use cyclotomics (avoid floats).
- **Balancing equation** is the fastest route to `S` from `(N, d, theta)`.
- **Galois orbits** are preserved as metadata via the database structure.
- **read_direct.g** has been extended to load `ModularData.gd/gi` for direct use.
