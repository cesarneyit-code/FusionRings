# Modular Data in FusionRings

This document is the single source of truth for the **ModularData** module:
- mathematical specification (admissible modular data),
- database format (NsdGOL),
- API and validation levels,
- tests and usage examples.

It is intended to remain within the FusionRings package and to be integrated
into GAPDoc later if desired.

---

## 1) Admissible Modular Data (specification)

We fix one notion of modular data: **admissible modular data**. A pair `(S,T)` is
admissible if it satisfies (i)–(vii) below. Indices are `1..r` in GAP, with unit
object at index `1`.

### Data and notation

- `r >= 1` is the **rank** (number of labels/simples).
- `S, T in GL_r(C)`.
- `T` is **diagonal**: `T_ij = delta_ij * theta_i`, `theta_i in C^*`.
- **Quantum dimensions**: `d_i := S_{1,i}`.
- **Global dimension (squared)**: `D^2 := sum_i d_i^2`.
- `N := ord(T)` is finite (all `theta_i` are roots of unity).

### (i) Symmetry/orthogonality of `S`; diagonal and finite order `T`

1. `S = S^t`.
2. `S * S^t = D^2 * I_r` (equivalently `S^{-1} = (1/D^2) * S^t`).
3. `T` is diagonal.
4. `ord(T) < infinity`.

### (ii) Modular equation and Gauss sums

Define **Gauss sums**:

```
p_+ := sum_k d_k^2 * theta_k
p_- := sum_k d_k^2 * theta_k^{-1}
```

Require:

1. `(S*T)^3 = p_+ * S^2`.
2. `p_+ * p_- = D^2`.
3. `p_+ / p_-` is a root of unity.

### (iii) Verlinde formula and integrality

```
N^k_ij := (1/D^2) * sum_a (S_{i a} * S_{j a} * S_{k a}) / S_{1 a}
```

Require `N^k_ij in N` for all `i,j,k`.

### (iv) Duality and balancing equation

Define dual `i*` by `N^1_{i,i*} = 1`. Require the **balancing equation**:

```
S_{i j} = sum_k N^k_{i j} * (theta_i * theta_j / theta_k) * d_k
```

### (v) Frobenius–Schur (FS) indicators

For `n >= 1`:

```
nu_n(k) := (1/D^2) * sum_{i,j} N^k_ij * d_i * d_j * (theta_i / theta_j)^n
```

Require:
- `nu_2(k) = 0` if `k != k*`.
- `nu_2(k) = ±1` if `k = k*`.
- `nu_n(k) in Z[e^{2 pi i / N}]` for all `n,k`.

### (vi) Fields and Galois symmetry (structural)

Let `F_T := Q_N` and `F_S` be the field generated by entries of `S`.
Require:
1. `F_S ⊆ F_T = Q_N`.
2. `Gal(F_S/Q)` acts by permuting labels (abelian subgroup of `S_r`).
3. `Gal(F_T/F_S) ≅ (Z/2Z)^ℓ`.

### (vii) Cauchy theorem (prime divisors)

The primes dividing `D^2` coincide with those dividing `N`.

---

## 2) Database format (NsdGOL)

The rank ≤ 12 database is stored as GAP records:

```
pkg/FusionRings/data/modular_data/NsdGOL2.g
pkg/FusionRings/data/modular_data/NsdGOL3.g
...
pkg/FusionRings/data/modular_data/NsdGOL12.g
```

Each file defines a global `NsdGOL` list of **Galois orbits**. For indices
`iGO` (orbit) and `iMD` (entry):

- `NsdGOL[iGO][iMD].Nij_k` = fusion coefficients `N^k_ij`.
- `NsdGOL[iGO][iMD].s` = spins `s_i` with `theta_i = exp(2 pi i s_i)`.
- `NsdGOL[iGO][iMD].d` = exact quantum dimensions.
- `NsdGOL[iGO][iMD].df` = floating approximations (debug only).

**Efficient reconstruction:** given `(N, s, d)`, build `theta` from `s`, then
reconstruct `S` using the balancing equation (no diagonalization).

### Rigidity vs. ambiguity (in terms of the database)

The database does **not** store `S` directly. This is intentional:

- If you only know the fusion rules `N` (or even `N` and `T`), the modular data
  is **not rigid**: you can permute labels, apply Galois conjugation, or change
  spherical structure, producing distinct (but related) modular data.
- The database resolves this by grouping entries into **Galois orbits**:
  `NsdGOL[iGO]` is one orbit, and `NsdGOL[iGO][iMD]` are the different members
  (each with its own `s` and `d`).
- Once you **choose an entry** (i.e. fix `N`, `s`, and `d`), the balancing
  equation determines `S` **uniquely** for that entry:

```
S_{ij} = sum_k N^k_{ij} * (theta_i * theta_j / theta_k) * d_k
```

So the ambiguity lives at the orbit level, while reconstruction is rigid at
the entry level.

---

## FAQ

**Q: Why does the database not store the `S`-matrix?**  
A: Because for each database entry, `S` is uniquely determined from
`(N, s, d)` by the balancing equation. Storing `S` would duplicate data and
risk inconsistency.

**Q: Why are there multiple entries per rank / orbit?**  
A: Modular data is not rigid under Galois action. The database groups entries
into Galois orbits; each entry represents a distinct Galois conjugate (or a
change of spherical structure) with its own `s` and `d`.

**Q: If I only know `N`, can I reconstruct `S`?**  
A: Not uniquely. You must choose a specific entry (i.e. fix `s` and `d`) from
the database. Once you do, the balancing equation fixes `S` uniquely.

---

## 3) ModularData API

### Constructors

- `ModularData(rec)`
  - If `rec` is a database record with `Nij_k, s, d`, builds `S, T` via balancing.
- `ModularDataFromNsdRecord(rec)`
  - Same as above, explicit.
- `ModularDataFromST(S, T[, labels])`
  - Wraps an existing `(S,T)`.

### Attributes

- `SMatrix(md)`
- `TMatrix(md)`
- `MDLabels(md)`
- `MDSpins(md)`
- `MDTwists(md)`
- `MDQuantumDimensions(md)`
- `MDGlobalDimensionSquared(md)`
- `MDFusionCoefficients(md)`
- `MDOrderT(md)`

### Database helpers

- `LoadNsdGOL(rank)`
  - Loads the database file for a given rank.
- `GetModularData(rank, iGO, iMD)`
  - Returns a `ModularData` object for the specified entry.

---

## 4) Validation levels

`ValidateModularData(md, level)` returns a record with:

- `ok` (boolean)
- `failures` (list of strings)

Levels implemented:

- **1**: shape checks, symmetry, `S*S^t = D^2 I`, `T` diagonal.
- **2**: Gauss sums + modular equation.
- **3**: Verlinde consistency (against stored `N` or integrality check).
- **4**: balancing equation.
- **5**: FS indicator `nu_2` constraints.
- **6**: partial field/Galois checks:
  - entries in `Q_N` (via `Conductor` when available),
  - `Gal(Q_N)` permutes columns up to sign (via `GaloisMat` if available,
    otherwise `GaloisCyc`).

- **7**: Cauchy primes check using `Norm(D^2)` when available
  (falls back to rational case if `D^2` is rational).

### To do / Improvements

- **Level 6 (full)**: construct the exact field `F_S = Q(S_ij)` and verify
  `Gal(F_S/Q)` acts by permutations; check that `Gal(Q_N/F_S)` is a 2-group.
  Current level 6 is a practical partial check.

---

## 5) Tests

ModularData tests live in `pkg/FusionRings/tst/`:

- `test_modulardata_basic.tst`: construct from `NsdGOL2`, symmetry/orthogonality, diagonal `T`.
- `test_modulardata_verlinde.tst`: Verlinde reconstruction matches `N`.
- `test_modulardata_gauss.tst`: Gauss sums + `(ST)^3 = p_+ S^2`.
- `test_modulardata_fs.tst`: `nu_2` constraints.
- `test_modulardata_cauchy.tst`: Cauchy primes in rational case.
- `test_modulardata_validate*.tst`: validator levels 1–7.
- `test_modulardata_loader.tst`: database loader helpers.

Run all tests (strict):

```
Read("/Users/cesargalindo/Documents/FusionRings/run_tests_strict.g");
```

---

## 5.1) Cyclotomics cheat-sheet (GAP)

Useful functions for exact arithmetic and field checks:

- `E(n)`: primitive `n`-th root of unity.
- `IsCyclotomic(x)`: test cyclotomic.
- `IsIntegralCyclotomic(x)`: cyclotomic integer test.
- `Conductor(x)` / `Conductor(list)`: smallest `n` with `x in Q_n`.
- `DenominatorCyc(x)`: smallest `m` with `m*x` cyclotomic integer.
- `GaloisCyc(x, k)`: Galois conjugate by `k` (when `gcd(k,n)=1`).
- `GaloisMat(mat)`: Galois orbits and generators for rows of a cyclotomic matrix.
- `DefaultField(list)`: smallest cyclotomic field containing given elements.
- `Norm(x)`: field norm (used for Cauchy condition in level 7).

Performance note: cyclotomic arithmetic can be expensive at large conductors;
prefer aggregate checks (e.g., `Conductor(Flat(S))`) when possible.

## 6) Usage examples

### Load a database entry

```
LoadNsdGOL(2);
md := GetModularData(2, 1, 1);
S := SMatrix(md);
T := TMatrix(md);
ValidateModularData(md, 4);
```

### Build from a database record directly

```
Read("/Users/cesargalindo/Documents/FusionRings/pkg/FusionRings/data/modular_data/NsdGOL2.g");
md := ModularDataFromNsdRecord(NsdGOL[1][1]);
```

---

## 7) Implementation notes

- **Exact arithmetic**: use cyclotomics (avoid floats).
- **Balancing equation** is the fastest route to `S` from `(N, d, theta)`.
- **Galois orbits** are preserved as metadata via the database structure.
- **read_direct.g** has been extended to load `ModularData.gd/gi` for direct use.
